#!/usr/bin/env python
# Copyright © 2025 ANSYS, Inc. Unauthorized use, distribution, or duplication is prohibited. 

################################################################################
#
# ModelCenter Remote Execution Source Code
#
# Copyright © 2025 ANSYS, Inc.
#
# DO NOT EDIT THIS FILE.
#
################################################################################

from __future__ import print_function

import time
import datetime
import argparse
import glob
import sys
import os
import traceback
import platform
import tempfile

"""
Get a few extra bonus prints.
"""
DEBUG = False

print("The Python Host was started at:", datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S'))
print("The Current Working Directory:", os.getcwd())

print("Python Version:", sys.version)

print("PYTHONPATH:", os.getenv('PYTHONPATH', None));
print("PYTHONHOME:", os.getenv('PYTHONHOME', None));


try:
   import pkg_resources
   print("Thrift Version:", pkg_resources.get_distribution("thrift").version)
   print("Six Version:", pkg_resources.get_distribution("six").version)
except:
   print("Missing pkg_resources import. Unable to get Thrift/Six versions.")


# Override print
print_noflush = print

def Flush():
   """
   Flushes stdout and stderr for logging.
   """
   sys.stdout.flush()
   sys.stderr.flush()
Flush()

def print(*args, **kwargs):
   """
   Print override with flush.
   """
   try:
      res = print_noflush(*args, **kwargs)
   except UnicodeEncodeError as ex:
      tracebackFormatException = traceback.format_exc()
      err = repr(ex).encode("utf-8")
      res = print_noflush("Non-ascii characters not supported:", tracebackFormatException, sep='\n')
   Flush()

   return res


def eprint(tb,ex,*args,**kwargs):
   """
   Prints to stderr and stdout for warnings and error messages.

   Parameters:
      - tb: exception traceback to display in stdErr.
      - ex: exception to display in stdErr.
   """
   print(*args,file=sys.stderr,**kwargs)
   print(tb,ex,file=sys.stderr,**kwargs)
   print(*args,file=sys.stdout,**kwargs)



def addImportPath(path):
   """
   Add given path to locatins imports can come from.

   Parameters:
      - path: folder to add to system path for imports
   """
   path = os.path.abspath(path)
   if DEBUG:
      print("Adding Import Path:", path)
   sys.path.append(path)

# import standard Thrift libraries

from thrift.protocol import TJSONProtocol
from thrift.protocol import TBinaryProtocol
from thrift.transport import TTransport
from thrift.transport import TSocket
from thrift import Thrift

# import phx Thrift ScriptWrapper Service
from com.phoenix_int.aserver.util.scriptwrapper.interprocess.ThriftScriptWrapperService import Client
from com.phoenix_int.aserver.util.scriptwrapper.interprocess.ttypes import GeneralError

# Creating our own hash of GeneralError to allow tracebacks.
GeneralError.__hash__ = lambda self: hash((self.Message))

# import global client container
import PHXPythonGlobals
import GenericPythonStructs

class ThriftClientWrapper:
   """
   Wraps the com.phoenix_int.aserver.util.scriptwrapper.interprocess.ThriftScriptWrapperService.Client object with auto closing nature.
   """
   def __init__(self,pipename,pipedir,timeout):
      """
      Constructor.

      Parameters:
         - pipename: The name of the pipe to hook into.
         - timout: The amount of time to attempt to connect to the pipe (in seconds).
      """
      self.pipename = pipename
      self.timeout = timeout
      self.pipedir = pipedir
      if DEBUG:
         print("Named Pipe:",self.pipename)

   def __enter__(self):
      """
      Using 'with' resource magic. Auto-closable init.
      """
      print("ThriftClientWrapper starting")
      if platform.system() == "Windows":
         pipename = os.path.join(r'\\.\pipe', self.pipename)
         self.inpipe = self.OpenPipeWithTimeout(pipename, "rb+", self.timeout)
         self.outpipe = self.inpipe
      else:
         if self.pipedir is None:
            pipedir = tempfile.gettempdir()
         else:
            pipedir = self.pipedir
         server_inpipe_name = os.path.join(pipedir, self.pipename + "in")
         server_outpipe_name = os.path.join(pipedir, self.pipename + "out")
         """
         It is important that the pipes are opened in this order.
         Opening a pipe on Linux blocks until the opposite handle has also been opened.
         The server tries to open its input pipe first, so if we try to do the opposite,
         we will both deadlock.
         """
         self.outpipe = self.OpenPipeWithTimeout(server_inpipe_name, "wb", self.timeout)
         self.inpipe = self.OpenPipeWithTimeout(server_outpipe_name, "rb", self.timeout)

      # Make socket
      self.itransport = TTransport.TBufferedTransport(TTransport.TFileObjectTransport(self.inpipe))
      self.otransport = TTransport.TBufferedTransport(TTransport.TFileObjectTransport(self.outpipe))

      # Wrap in a protocol
      """
      Note: Below are the following implementations of org.apache.thrift.protocol.TProtocol taken from the current
      version of the JavaDocs for Thrift. If you change it here, also make sure to change it in
      svn+ssh://svn.phoenix-int.com/opt/svn/MCAS/trunk/ASERVER/netbeans/src/com/phoenix_int/aserver/util/scriptwrapper/thrift/python/PythonThriftHandler.java
      file.
      TBinaryProtocol, TCompactProtocol, TJSONProtocol, TProtocolDecorator, TSimpleJSONProtocol
      """
      if False:
         self.iprotocol = TBinaryProtocol.TBinaryProtocol(self.itransport)
         self.oprotocol = TBinaryProtocol.TBinaryProtocol(self.otransport)
      else:
         self.iprotocol = TJSONProtocol.TJSONProtocol(self.itransport)
         self.oprotocol = TJSONProtocol.TJSONProtocol(self.otransport)

      # Create a client to use the protocol encoder
      self.client = Client(self.iprotocol, self.oprotocol)
      print("ThriftClientWrapper started:",type(self.client).__name__)

      return self

   def __exit__(self, exc_type, exc_val, exc_tb):
      """
      Auto close for 'with' magic. Auto-closable cleanup.
      """
      print("ThriftClientWrapper exiting")
      self.itransport.close()
      self.otransport.close()
      print("ThriftClientWrapper exited")

   def OpenPipeWithTimeout(self, pipename, mode, timeout):
      """
      Attempt to open a pipe in a given timeout.

      Parameters:
         - pipename: The name of the pipe to hook into.
         - timout: The amount of time to attempt to connect to the pipe (in seconds).

      Returns:
         - An open pipe
      """
      print("Connecting to pipe:", pipename," Timeout:",timeout)

      stop_time = time.time() + timeout

      while time.time() < stop_time:
         try:
            pipe = open(pipename, mode, buffering=0)
            if DEBUG:
               print("Named pipe openned.")
            return pipe

         except Exception as ex:
            # TODO: Remove print from production
            print("Waiting for Named Pipe.")
            time.sleep(1)

      raise Exception("Timed out attempting to connect to pipe " + pipename + ".")

   def GetNextTask(self):
      """
      Ask thrift server until information is sent. This is often a long blocking call.

      Returns:
         - The method to execute in the script.
      """
      try:
         print("Waiting for next task...  ",end="")
         methodName = self.client.GetNewRun()
         print("Next task:", methodName)
         return methodName

      except TTransport.TTransportException as ex:
         tracebackFormatException = traceback.format_exc()
         eprint(tracebackFormatException, ex, "Error: Unable to get next task")
         return None


   def init(self):
      """
      Get the initialization information for the calling instance.  Returns the path to the script wrapper file to run.
      """
      return self.client.init(str(time.time()))

   def initSuccess(self):
      """
      Signal MCRE that the client script has completed initialization.
      """
      self.client.initSuccess()

   def initFailed(self,msg):
      """
      Signal MCRE that the client script has completed initialization, but with an error.

      Parameters:
         - msg: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.
      """
      self.client.initFailed(msg)

   def Success(self):
      """
      Signals the end of a successful run.
      """
      self.client.Success()

   def Failed(self,msg):
      """
      Signals the end a failed run.

      Parameters:
         - msg: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.
      """
      self.client.Failed(msg)


class ExecutionEngine:
   """
   Wraps and manages the execution (exec) of custom code snipits, such as the preamble, scriptWrapper body, and runs.
   """
   def __init__(self,scriptWrapperInitialization):
      """
      Constructor.

      Parameters:
         - scriptWrapperInitialization: the scriptWrapperInitialization object from Java side, that includes preamble and script body.
      """
      self.script = scriptWrapperInitialization.script
      self.preamble = scriptWrapperInitialization.preamble
      self.scriptGlobalVars = {"print":print} # Dictionary to store globals from read script


   def execute(self,text,userCode=True):
      """
      Execute some python text/code in this engines scope.

      Parameters:
         - text: the python text/code to execute
      """
      try:
         if userCode:
            print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Script Execution>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
         exec(text,self.scriptGlobalVars)
      finally:
         if userCode:
            print("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<Script Done<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
         Flush()

   def LoadScript(self):
      """
      "Initializes" a python script
      """

      prepreamble = """
import PHXPythonGlobals
print("Inside Preamble:",type(PHXPythonGlobals.clientFaker).__name__)
phxPython = PHXPythonGlobals.clientFaker
import GenericPythonStructs as phx
from GenericPythonStructs import *
"""
      preamble = prepreamble+self.preamble

      if DEBUG:
         print("Preamble:",preamble.strip(),sep="\n\n")

      print("-----------------------------------Script Body----------------------------------")
      print(self.script.strip())
      print("--------------------------------------------------------------------------------")

      print("Executing Preamble:",sep="\n\n")
      self.execute(preamble,False)
      print("Preamble Loaded. Loading script body.")
      self.execute(self.script)

   def RunScript(self, method):
      """
      Executes the run method in a Python scriptWrapper file.

      Parameters:
         - method: The method to execute in the script provided.
      """
      if DEBUG:
         print("RunScript method: " + method)
         print("\n\nGlobals before run:")
         for v in self.scriptGlobalVars:
            print(v, end = ' ')
         print("")

      methodName = "" + method + "()"
      self.execute(methodName)

      # Call run method. Should be loaded by script.
      # extracted_run_method = scriptLocalVars[method]
      # extracted_run_method()

      # This needs to be worked on. We need to grab only the variables
      #  that are to be given back to MCRE.
      if DEBUG:
         print("About to print scriptGlobalVars:")
         for var in self.scriptGlobalVars:
            print(var, end = ' ')
         print("")


def main(pipename, pipedir):
   """
   Creates a new thrift python host client.

   Parameters:
      - pipename: Path to the pipe to connect to.
      - pipedir: a specific directory in which the pipe will be contained
   """
   with ThriftClientWrapper(pipename, pipedir, 60) as clientWrapper:

      if DEBUG:
         print("ThriftClientWrapper:",type(clientWrapper).__name__)
      PHXPythonGlobals.clientFaker = clientWrapper.client

      if False: # For testing initialization timeout behavior. Should be False for production|SVN.
         time.sleep(31)
      scriptWrapperInitialization = clientWrapper.init()

      executionEngine = ExecutionEngine(scriptWrapperInitialization)

      try:
         executionEngine.LoadScript()

      except Exception as ex:
         tracebackFormatException = traceback.format_exc()
         eprint(tracebackFormatException, ex, "Error: Exception while loading script.")
         clientWrapper.initFailed( tracebackFormatException )
         return

      clientWrapper.initSuccess()

      while True:
         method = clientWrapper.GetNextTask()

         if method is "":
            print("Detected `shutdown`. Cleaning up and exiting.")
            clientWrapper.Success() # acknowledge the shutdown
            return

         # TODO Trap if method does not exist and report failure differently
         try:
            executionEngine.RunScript(method)
         except GenericPythonStructs.PHXException as ex:
            tracebackFormatException = traceback.format_exc()
            eprint(tracebackFormatException, ex, "Error: Java Exception when running script.")
            clientWrapper.Failed( tracebackFormatException )
         except Exception as ex:
            tracebackFormatException = traceback.format_exc()
            eprint(tracebackFormatException, ex, "Error: Unknown exception when running script.")
            clientWrapper.Failed( tracebackFormatException )

         else:
            clientWrapper.Success()



Flush()

if __name__ == '__main__':
   parser = argparse.ArgumentParser()
   parser.add_argument('-pipename', dest='pipename', type=str,
                       required=True, help='Named pipe to connect to.')
   parser.add_argument('-clientid', dest='clientid', type=str,
                       required=False, help="The client machine's id.")
   parser.add_argument('-pipedir', dest='pipedir', type=str,
                       required=False, help='On Linux, the directory in which the pipe is contained.')

   try:
      # Access the arguments with:
      #   - args.pipename
      #   - args.clientid
      #   - args.pipedir
      args = parser.parse_args()

      main(args.pipename, args.pipedir)

   except Exception as ex:
      tracebackFormatException = traceback.format_exc()
      eprint(tracebackFormatException, ex, "Error: Python Client failed.")
