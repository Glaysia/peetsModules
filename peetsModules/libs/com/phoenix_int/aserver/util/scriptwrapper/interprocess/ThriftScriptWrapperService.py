#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    Methods for out of process handlers to call to get work and return results to ModelCenter Remote Execution;
    and to manipulate the ModelCenter Remote Execution objects.

    """
    def init(self, epoch):
        """
        Get the initialization information for the calling instance.  Returns the path to the script wrapper file to
        run.

        Parameters:
         - epoch: Python Epoch, to ensure bidirectional communication.

        """
        pass

    def initSuccess(self):
        """
        Signal MCRE that the client script has completed initialization.

        """
        pass

    def initFailed(self, error):
        """
        Signal MCRE that the client script has completed initialization, but with an error.

        Parameters:
         - error: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.  Typically
        such messages include (but only message is required):
           * Error message
           * Stack trace of script files and line numbers.

        """
        pass

    def GetNewRun(self):
        """
        Get information on the next task to run. This call may block until a new run is available.
        Returns name of method to run, typically "run".  Will return "" (TerminateRun const) when MCRE is finished with
        the current script session.

        """
        pass

    def Success(self):
        """
        Signals the end of a successful run.

        """
        pass

    def Failed(self, error):
        """
        Signals the end a failed run.

        Parameters:
         - error: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.  Typically
        such messages include (but only message is required):
           * Error message
           * Stack trace of script files and line numbers.

        """
        pass

    def boolGetValue(self, varName):
        """
        retrieves the current value of the variable

        Parameters:
         - varName

        """
        pass

    def boolSetValue(self, varName, boolVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - boolVal

        """
        pass

    def boolToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        pass

    def boolArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def boolArrayGetValue(self, varName, index):
        """
        retrieves the current value of the variable

        Parameters:
         - varName
         - index

        """
        pass

    def boolArrayGetValueStr(self, varName, index):
        """
        retrieves the current value of the variable (in string form)

        Parameters:
         - varName
         - index

        """
        pass

    def boolArraySetValue(self, varName, index, boolVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - index
         - boolVal

        """
        pass

    def boolArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        pass

    def dblFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def dblGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def dblGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        pass

    def dblGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        pass

    def dblGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        pass

    def dblGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        pass

    def dblGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        pass

    def dblGetValue(self, varName):
        """
        retrieves the current value of the variable

        Parameters:
         - varName

        """
        pass

    def dblSetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblSetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblSetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblSetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def dblSetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def dblSetLowerBound(self, varName, dblVal):
        """
        sets the lower bound

        Parameters:
         - varName
         - dblVal

        """
        pass

    def dblSetUpperBound(self, varName, dblVal):
        """
        sets the upper bound

        Parameters:
         - varName
         - dblVal

        """
        pass

    def dblSetValue(self, varName, dblVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - dblVal

        """
        pass

    def dblToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        pass

    def dblArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def dblArrayGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def dblArrayGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def dblArrayGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        pass

    def dblArrayGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        pass

    def dblArrayGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        pass

    def dblArrayGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        pass

    def dblArrayGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        pass

    def dblArrayGetValue(self, varName, index):
        """
        retrieves the current value of the variable with the associated index

        Parameters:
         - varName
         - index

        """
        pass

    def dblArraySetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblArraySetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblArraySetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        pass

    def dblArraySetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def dblArraySetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def dblArraySetLowerBound(self, varName, dblVal):
        """
        sets the lower bound

        Parameters:
         - varName
         - dblVal

        """
        pass

    def dblArraySetUpperBound(self, varName, dblVal):
        """
        sets the upper bound

        Parameters:
         - varName
         - dblVal

        """
        pass

    def dblArraySetValue(self, varName, index, dblVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - index
         - dblVal

        """
        pass

    def dblArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        pass

    def longFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        pass

    def longGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def longGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def longGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        pass

    def longGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        pass

    def longGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        pass

    def longGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        pass

    def longGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        pass

    def longGetValue(self, varName):
        """
        retrieves the current value of the variable

        Parameters:
         - varName

        """
        pass

    def longSetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def longSetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def longSetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        pass

    def longSetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def longSetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def longSetLowerBound(self, varName, value):
        """
        sets the lower bound

        Parameters:
         - varName
         - value

        """
        pass

    def longSetUpperBound(self, varName, value):
        """
        sets the upper bound

        Parameters:
         - varName
         - value

        """
        pass

    def longSetValue(self, varName, value):
        """
        sets the value for the variable

        Parameters:
         - varName
         - value

        """
        pass

    def longToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        pass

    def longArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def longArrayGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def longArrayGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        pass

    def longArrayGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        pass

    def longArrayGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        pass

    def longArrayGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        pass

    def longArrayGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        pass

    def longArrayGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        pass

    def longArrayGetValue(self, varName, index):
        """
        retrieves the current value of the variable with the associated index

        Parameters:
         - varName
         - index

        """
        pass

    def longArraySetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def longArraySetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        pass

    def longArraySetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        pass

    def longArraySetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def longArraySetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def longArraySetLowerBound(self, varName, value):
        """
        sets the lower bound

        Parameters:
         - varName
         - value

        """
        pass

    def longArraySetUpperBound(self, varName, value):
        """
        sets the upper bound

        Parameters:
         - varName
         - value

        """
        pass

    def longArraySetValue(self, varName, index, value):
        """
        sets the value for the variable

        Parameters:
         - varName
         - index
         - value

        """
        pass

    def longArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        pass

    def fileFromFile(self, varName, fileName):
        """
        Sets the filename and then reads from disk.

        Parameters:
         - varName
         - fileName

        """
        pass

    def fileFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        pass

    def fileGetBaseName(self, varName):
        """
        gets the base name of the file

        Parameters:
         - varName

        """
        pass

    def fileGetContents(self, varName):
        """
        retrieves the contents of the file

        Parameters:
         - varName

        """
        pass

    def fileGetFileExtension(self, varName):
        """
        Returns the extension of the file that this object represents

        Parameters:
         - varName

        """
        pass

    def fileGetIsBinary(self, varName):
        """
        Tells whether or not the the file is binary.

        Parameters:
         - varName

        """
        pass

    def fileGetMimeType(self, varName):
        """
        Get the MIME type for the file

        Parameters:
         - varName

        """
        pass

    def fileGetName(self, varName):
        """
        retrieves the name of the file

        Parameters:
         - varName

        """
        pass

    def fileGetNameCoded(self, varName):
        """
        retrieves the name of the file in coded form (without $variables replaced)

        Parameters:
         - varName

        """
        pass

    def fileHasChanged(self, varName):
        """
        checks to see if the file has changed since the last time getContents() was called

        Parameters:
         - varName

        """
        pass

    def fileMarkAsRead(self, varName):
        """
        call this function after you manually get the contents of the file.

        Parameters:
         - varName

        """
        pass

    def fileSetBaseName(self, varName, name):
        """
        sets the base name of the file

        Parameters:
         - varName
         - name

        """
        pass

    def fileSetContents(self, varName, contents):
        """
        sets the contents of the file.

        Parameters:
         - varName
         - contents

        """
        pass

    def fileSetFileExtension(self, varName, extension):
        """
        Sets the extension of the file that this object represents.

        Parameters:
         - varName
         - extension

        """
        pass

    def fileSetIsBinary(self, varName, boolVal):
        """
        Forces this file to be binary or not.

        Parameters:
         - varName
         - boolVal

        """
        pass

    def fileSetMimeType(self, varName, mimeType):
        """
        Set the MIME type for the file

        Parameters:
         - varName
         - mimeType

        """
        pass

    def fileSetName(self, varName, strVal):
        """
        sets the name of the file

        Parameters:
         - varName
         - strVal

        """
        pass

    def fileToFile(self, varName, strVal):
        """
        sets the filename and then writes the file to disk.

        Parameters:
         - varName
         - strVal

        """
        pass

    def fileToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        pass

    def fileArrayFromFile(self, varName, index, fileName):
        """
        Sets the filename and then reads from disk.

        Parameters:
         - varName
         - index
         - fileName

        """
        pass

    def fileArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def fileArrayGetBaseName(self, varName):
        """
        gets the base name of the file

        Parameters:
         - varName

        """
        pass

    def fileArrayGetContents(self, varName, index):
        """
        retrieves the contents of the file

        Parameters:
         - varName
         - index

        """
        pass

    def fileArrayGetFileExtension(self, varName, index):
        """
        Returns the extension of the file that this object represents

        Parameters:
         - varName
         - index

        """
        pass

    def fileArrayGetIsBinary(self, varName):
        """
        Tells whether or not the the file is binary.

        Parameters:
         - varName

        """
        pass

    def fileArrayGetMimeType(self, varName):
        """
        Get the MIME type for the files

        Parameters:
         - varName

        """
        pass

    def fileArrayGetName(self, varName, index):
        """
        retrieves the name of the file

        Parameters:
         - varName
         - index

        """
        pass

    def fileArrayGetNameCoded(self, varName, index):
        """
        retrieves the name of the file in coded form (without $variables replaced)

        Parameters:
         - varName
         - index

        """
        pass

    def fileArrayHasChanged(self, varName, index):
        """
        checks to see if the file has changed since the last time getContents() was called

        Parameters:
         - varName
         - index

        """
        pass

    def fileArrayMarkAsRead(self, varName, index):
        """
        call this function after you manually get the contents of the file.

        Parameters:
         - varName
         - index

        """
        pass

    def fileArraySetBaseName(self, varName, name):
        """
        sets the base name of the file

        Parameters:
         - varName
         - name

        """
        pass

    def fileArraySetContents(self, varName, index, contents):
        """
        sets the contents of the file.

        Parameters:
         - varName
         - index
         - contents

        """
        pass

    def fileArraySetFileExtension(self, varName, index, extension):
        """
        Sets the extension of the file that this object represents.

        Parameters:
         - varName
         - index
         - extension

        """
        pass

    def fileArraySetIsBinary(self, varName, boolVal):
        """
        Forces this file to be binary or not.

        Parameters:
         - varName
         - boolVal

        """
        pass

    def fileArraySetMimeType(self, varName, mimeType):
        """
        Set the MIME type for the files

        Parameters:
         - varName
         - mimeType

        """
        pass

    def fileArraySetName(self, varName, index, strVal):
        """
        sets the name of the file

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def fileArrayToFile(self, varName, index, strVal):
        """
        sets the filename and then writes the file to disk.

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def fileArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        pass

    def newPHXRowFieldFile(self, mode):
        """
        creates a new PHXRowFieldFile object

        Parameters:
         - mode

        """
        pass

    def rffClearMarks(self, key):
        """
        Removes effects of any previous markAsBeginning() or markAsEnd() calls

        Parameters:
         - key

        """
        pass

    def rffClose(self, key):
        """
        Closes the input file and frees up resources associated w/ this RowFieldFile.

        Parameters:
         - key

        """
        pass

    def rffDelete(self, key):
        """
        deletes a PHXRowFieldFile object

        Parameters:
         - key

        """
        pass

    def rffGenerate(self, key):
        """
        If mode is GENERATE, this function actually writes the output file to disk.

        Parameters:
         - key

        """
        pass

    def rffMarkAsBeginning(self, key, find, occurrence, offset, regex):
        """
        Searches for the specified string and makes the row where the string was found act as row 1 for all subsequent
        calls until another markAsBeginning or clearMarks call.

        Parameters:
         - key
         - find
         - occurrence
         - offset
         - regex

        """
        pass

    def rffMarkAsEnd(self, key, find, occurrence, offset, regex):
        """
        Searches for the specified string and makes the row where the string was found act as row -1 (end of file) for
        all subsequent calls until another markAsEnd or clearMarks call.

        Parameters:
         - key
         - find
         - occurrence
         - offset
         - regex

        """
        pass

    def rffReadDouble(self, key, row, field):
        """
        Reads a value out of the input file.

        Parameters:
         - key
         - row
         - field

        """
        pass

    def rffReadLong(self, key, row, field):
        """
        Reads a value out of the input file.

        Parameters:
         - key
         - row
         - field

        """
        pass

    def rffReadValue(self, key, row, field):
        """
        Reads a value out of the input file.

        Parameters:
         - key
         - row
         - field

        """
        pass

    def rffSetDelimiters(self, key, delimiters):
        """
        Sets the delimiters which should be used for parsing lines into fields.

        Parameters:
         - key
         - delimiters

        """
        pass

    def rffSetFileToGenerateOrParse(self, key, fileName):
        """
        Specified the file which will be generated or parsed depending on the mode.

        Parameters:
         - key
         - fileName

        """
        pass

    def rffSetTemplateFile(self, key, fileName):
        """
        Specified the template file to read.

        Parameters:
         - key
         - fileName

        """
        pass

    def rffTransferArray(self, key, varName, rowstart, rowend, fieldstart, fieldend, resizable, format, numDimensions):
        """
        Transfers the data for a particular array.

        Parameters:
         - key
         - varName
         - rowstart
         - rowend
         - fieldstart
         - fieldend
         - resizable
         - format
         - numDimensions

        """
        pass

    def rffTransferKeyVar(self, key, varName, searchKey, occurrence, rowOffset, field, fformat):
        """
        Transfers the data for a particular variable.

        Parameters:
         - key
         - varName
         - searchKey
         - occurrence
         - rowOffset
         - field
         - fformat

        """
        pass

    def rffTransferVar(self, key, varName, row, field, format):
        """
        Transfers the data for a particular variable.

        Parameters:
         - key
         - varName
         - row
         - field
         - format

        """
        pass

    def rffWriteValue(self, key, row, field, val):
        """
        Writes a token out to the output file.

        Parameters:
         - key
         - row
         - field
         - val

        """
        pass

    def runShareCleanTempDir(self):
        """
        cleans up the temporary run directory if one has been created.

        """
        pass

    def runShareGetBaseDirectory(self):
        """
        Gets the base dir which was passed in to the constructor.

        """
        pass

    def runShareGetDirectory(self):
        """
        Returns the current directory being used by the runshare system.

        """
        pass

    def runShareHalt(self):
        """
        halts any running process

        """
        pass

    def runShareLock(self):
        """
        Causes the run-share mode to be implemented.

        """
        pass

    def runShareRun(self, cmd, ignoreErrors, autoChangeDir, shell):
        """
        Runs a command.

        Parameters:
         - cmd
         - ignoreErrors
         - autoChangeDir
         - shell

        """
        pass

    def runShareSetAutoDelete(self, autoDelete):
        """
        Sets the auto-delete mode for runshare mode MODE_SHARE.

        Parameters:
         - autoDelete

        """
        pass

    def runShareSetFilesToCopy(self, files):
        """
        Sets the files which need to be copied when runshare mode is MODE_SHARE.

        Parameters:
         - files

        """
        pass

    def runShareSetMode(self, mode):
        """
        Sets the runshare mode.

        Parameters:
         - mode

        """
        pass

    def runShareUnlock(self):
        """
        Unlocks the runshare mechanisms.

        """
        pass

    def objCallMethod(self, varName, method):
        """
        call an object method
        TODO: This methods needs to return something that can be transformed into the possible return value types.
              e.g. a struct of two strings (type and value), which can be used to construct an object which will be
              a string; a boxed integer or double; a list of strings, integers or doubles.
        TODO: In Python, this method is going to needs some processing of the return value before it can be consumed
              directly by pythonStructs.py, see PHXScriptObject.callMethod line 2527.

        Parameters:
         - varName
         - method

        """
        pass

    def objDeleteAllMembers(self, varName):
        """
        delete all members

        Parameters:
         - varName

        """
        pass

    def objDeleteMember(self, varName, mIndex):
        """
        delete a member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objFromFile(self, varName, mIndex, fileName):
        """
        set content of a file member from a file

        Parameters:
         - varName
         - mIndex
         - fileName

        """
        pass

    def objFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        pass

    def objFromXML(self, varName, strVal):
        """
        set the content of the object from the XML string

        Parameters:
         - varName
         - strVal

        """
        pass

    def objGetBooleanArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of a boolean array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        pass

    def objGetBooleanMemberValue(self, varName, mIndex):
        """
        return value of a boolean member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetClassURL(self, varName):
        """
        return the class URL

        Parameters:
         - varName

        """
        pass

    def objGetDoubleArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of a double array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        pass

    def objGetDoubleMemberValue(self, varName, mIndex):
        """
        return value of a double member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetFileName(self, varName, mIndex):
        """
        return file name of a file member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetIntArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of an int array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        pass

    def objGetIntMemberValue(self, varName, mIndex):
        """
        return value of an int member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetIsBinary(self, varName, mIndex):
        """
        return True if file member contains a binary file

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberDescription(self, varName, mIndex):
        """
        return description of the member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberDimensions(self, varName, mIndex):
        """
        get dimensions of an array member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberEnumAliases(self, varName, mIndex):
        """
        return enum aliases of the member as a comma separated string

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberEnumValues(self, varName, mIndex):
        """
        return enum values of the member as a comma separated string

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberLength(self, varName, mIndex, dim):
        """
        return length of an array member

        Parameters:
         - varName
         - mIndex
         - dim

        """
        pass

    def objGetMemberLowerBound(self, varName, mIndex):
        """
        return lowerBound of the member as a string

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberNumDimensions(self, varName, mIndex):
        """
        get number of dimensions of an array member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberProperty(self, varName, mIndex, propertyName):
        """
        return a meta data property of the member

        Parameters:
         - varName
         - mIndex
         - propertyName

        """
        pass

    def objGetMemberType(self, varName, mIndex):
        """
        get type of a member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberUnits(self, varName, mIndex):
        """
        return units of the member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberUpperBound(self, varName, mIndex):
        """
        return upperBound of the member as a string

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetMemberValueAsString(self, varName, mIndex):
        """
        return member value as a string

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objGetStringArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of a string array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        pass

    def objGetStringMemberValue(self, varName, mIndex):
        """
        return value of a string member

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objHasMember(self, varName, mIndex):
        """
        return true if the member exists

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objHasMemberLowerBound(self, varName, mIndex):
        """
        return true if the member has the lowerBound defined

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objHasMemberUpperBound(self, varName, mIndex):
        """
        return true if the member has the upperBound defined

        Parameters:
         - varName
         - mIndex

        """
        pass

    def objIsNonStrictType(self, varName):
        """
        return true if the object is a non-strict type

        Parameters:
         - varName

        """
        pass

    def objSetBaseName(self, varName, mIndex, value):
        """
        set base name of a file member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetBooleanArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a boolean array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        pass

    def objSetBooleanMemberValue(self, varName, mIndex, boolVal):
        """
        set value of a boolean member

        Parameters:
         - varName
         - mIndex
         - boolVal

        """
        pass

    def objSetDoubleArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a double array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        pass

    def objSetDoubleMemberValue(self, varName, mIndex, value):
        """
        set value of a double member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetFileExtension(self, varName, mIndex, value):
        """
        set file extension of a file member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetFileName(self, varName, mIndex, value):
        """
        set file name of a file member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetIntArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a int array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        pass

    def objSetIntMemberValue(self, varName, mIndex, value):
        """
        set value of a int member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetIsBinary(self, varName, mIndex, flag):
        """
        set binary flag for the file member

        Parameters:
         - varName
         - mIndex
         - flag

        """
        pass

    def objSetMember(self, varName, mIndex, value, type):
        """
        set member. Create a member if not exists.

        Parameters:
         - varName
         - mIndex
         - value
         - type

        """
        pass

    def objSetMemberDescription(self, varName, mIndex, value):
        """
        set description of the member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetMemberDimensions(self, varName, mIndex, strVal):
        """
        set dimensions of an array member

        Parameters:
         - varName
         - mIndex
         - strVal

        """
        pass

    def objSetMemberEnumAliases(self, varName, mIndex, value):
        """
        set enum aliases of the member from a comma separated string

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetMemberEnumValues(self, varName, mIndex, value):
        """
        set enum values of the member from a comma separated string

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetMemberLength(self, varName, mIndex, length, dim):
        """
        set length of an array member

        Parameters:
         - varName
         - mIndex
         - length
         - dim

        """
        pass

    def objSetMemberLowerBound(self, varName, mIndex, value):
        """
        set lowerBound of the member from string

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetMemberProperty(self, varName, mIndex, propertyName, propertyValue):
        """
        set a meta data property of the member

        Parameters:
         - varName
         - mIndex
         - propertyName
         - propertyValue

        """
        pass

    def objSetMemberUnits(self, varName, mIndex, value):
        """
        set units of the member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetMemberUpperBound(self, varName, mIndex, value):
        """
        set upperBound of the member from string

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetMemberValueFromString(self, varName, mIndex, value):
        """
        set value of a member from a string value

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objSetStringArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a string array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        pass

    def objSetStringMemberValue(self, varName, mIndex, value):
        """
        set value of a string member

        Parameters:
         - varName
         - mIndex
         - value

        """
        pass

    def objToFile(self, varName, mIndex, fileName):
        """
        write content of a file member to a file

        Parameters:
         - varName
         - mIndex
         - fileName

        """
        pass

    def objToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        pass

    def objToXML(self, varName):
        """
        return XML representation of the object

        Parameters:
         - varName

        """
        pass

    def wrapperAddMethod(self, methodName, fullName, downloadInputs):
        """
        register a custom method with the component

        Parameters:
         - methodName
         - fullName
         - downloadInputs

        """
        pass

    def wrapperAddVariable(self, varName, varType, isInput):
        """
        add a new variable to the component

        Parameters:
         - varName
         - varType
         - isInput

        """
        pass

    def wrapperGetDictKey(self, index):
        """
        gets the dictionary key of the given index

        Parameters:
         - index

        """
        pass

    def wrapperGetDictNumEntries(self):
        """
        gets the number of items in the connection's dictionary

        """
        pass

    def wrapperGetDictValue(self, index):
        """
        gets the dictionary value of the given index

        Parameters:
         - index

        """
        pass

    def wrapperGetDirectory(self):
        """
        Returns the directory where this component was loaded from

        """
        pass

    def wrapperGetRunDirectory(self):
        """
        Returns the current run directory, which is the same as getDirectory() unless run sharing is being used.

        """
        pass

    def wrapperGetVarType(self, varName):
        """
        gets the type of the specified variable

        Parameters:
         - varName

        """
        pass

    def wrapperRemoveVariable(self, varName):
        """
        Dynamically removes a variable from this component

        Parameters:
         - varName

        """
        pass

    def wrapperSleep(self, milliSeconds):
        """
        sleeps for a period of time

        Parameters:
         - milliSeconds

        """
        pass

    def arrayFromString(self, varName, strVal):
        """
        reads in the entire array in string form.

        Parameters:
         - varName
         - strVal

        """
        pass

    def arrayGetDimensions(self, varName):
        """
        Gets the dimensions of the array in string form

        Parameters:
         - varName

        """
        pass

    def arrayGetLength(self, varName, dim):
        """
        Gets the length of a dimension of the array

        Parameters:
         - varName
         - dim

        """
        pass

    def arrayGetLockResize(self, varName):
        """
        Return whether the array be resized

        Parameters:
         - varName

        """
        pass

    def arrayGetNumDimensions(self, varName):
        """
        Gets the number of dimensions the array has

        Parameters:
         - varName

        """
        pass

    def arrayLockDimensions(self, varName):
        """
        Tells this array that the number of dimensions cannot be changed from what they are right now.

        Parameters:
         - varName

        """
        pass

    def arraySetDimensions(self, varName, strVal):
        """
        Sets the dimensions of the array from a string

        Parameters:
         - varName
         - strVal

        """
        pass

    def arraySetLength(self, varName, length, dim):
        """
        Sets the length of a dimensions of the array.

        Parameters:
         - varName
         - length
         - dim

        """
        pass

    def arraySetLockResize(self, varName, boolVal):
        """
        Tells this array that it cannot be resized.

        Parameters:
         - varName
         - boolVal

        """
        pass

    def arrayToString(self, varName):
        """
        Returns the string form of this array.

        Parameters:
         - varName

        """
        pass

    def simpleGetDescription(self, varName):
        """
        get the description

        Parameters:
         - varName

        """
        pass

    def simpleGetHasChanged(self, varName):
        """
        get the hasChanged flag

        Parameters:
         - varName

        """
        pass

    def simpleGetUnits(self, varName):
        """
        get the units

        Parameters:
         - varName

        """
        pass

    def simpleSetDescription(self, varName, strVal):
        """
        set the description

        Parameters:
         - varName
         - strVal

        """
        pass

    def simpleSetHasChanged(self, varName, boolVal):
        """
        set the hasChanged flag

        Parameters:
         - varName
         - boolVal

        """
        pass

    def simpleSetUnits(self, varName, strVal):
        """
        set the units

        Parameters:
         - varName
         - strVal

        """
        pass

    def strGetEnumAliases(self, varName):
        """
        gets the enumerated aliases as a comma-separated list

        Parameters:
         - varName

        """
        pass

    def strGetEnumValues(self, varName):
        """
        gets the enumerated values as a comma-separated list

        Parameters:
         - varName

        """
        pass

    def strGetValue(self, varName):
        """
        gets the value of a string variable

        Parameters:
         - varName

        """
        pass

    def strSetEnumAliases(self, varName, strVal):
        """
        sets the enumerated aliases with a comma-separated list

        Parameters:
         - varName
         - strVal

        """
        pass

    def strSetEnumValues(self, varName, strVal):
        """
        sets the enumerated values with a comma-separated list

        Parameters:
         - varName
         - strVal

        """
        pass

    def strSetValue(self, varName, strVal):
        """
        sets the value of a string variable

        Parameters:
         - varName
         - strVal

        """
        pass

    def strArrayFromString(self, varName, index, value):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - value

        """
        pass

    def strArrayGetEnumAliases(self, varName):
        """
        gets the enumerated aliases as a comma-separated list

        Parameters:
         - varName

        """
        pass

    def strArrayGetEnumValues(self, varName):
        """
        gets the value of a string variable

        Parameters:
         - varName

        """
        pass

    def strArrayGetValue(self, varName, index):
        """
        sets the enumerated aliases with a comma-separated list

        Parameters:
         - varName
         - index

        """
        pass

    def strArraySetEnumAliases(self, varName, strVal):
        """
        sets the enumerated values with a comma-separated list

        Parameters:
         - varName
         - strVal

        """
        pass

    def strArraySetEnumValues(self, varName, strVal):
        """
        sets the value of a string variable

        Parameters:
         - varName
         - strVal

        """
        pass

    def strArraySetValue(self, varName, index, strVal):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index
         - strVal

        """
        pass

    def strArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        pass


class Client(Iface):
    """
    Methods for out of process handlers to call to get work and return results to ModelCenter Remote Execution;
    and to manipulate the ModelCenter Remote Execution objects.

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def init(self, epoch):
        """
        Get the initialization information for the calling instance.  Returns the path to the script wrapper file to
        run.

        Parameters:
         - epoch: Python Epoch, to ensure bidirectional communication.

        """
        self.send_init(epoch)
        return self.recv_init()

    def send_init(self, epoch):
        self._oprot.writeMessageBegin('init', TMessageType.CALL, self._seqid)
        args = init_args()
        args.epoch = epoch
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_init(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = init_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "init failed: unknown result")

    def initSuccess(self):
        """
        Signal MCRE that the client script has completed initialization.

        """
        self.send_initSuccess()
        self.recv_initSuccess()

    def send_initSuccess(self):
        self._oprot.writeMessageBegin('initSuccess', TMessageType.CALL, self._seqid)
        args = initSuccess_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initSuccess(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initSuccess_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def initFailed(self, error):
        """
        Signal MCRE that the client script has completed initialization, but with an error.

        Parameters:
         - error: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.  Typically
        such messages include (but only message is required):
           * Error message
           * Stack trace of script files and line numbers.

        """
        self.send_initFailed(error)
        self.recv_initFailed()

    def send_initFailed(self, error):
        self._oprot.writeMessageBegin('initFailed', TMessageType.CALL, self._seqid)
        args = initFailed_args()
        args.error = error
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initFailed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initFailed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def GetNewRun(self):
        """
        Get information on the next task to run. This call may block until a new run is available.
        Returns name of method to run, typically "run".  Will return "" (TerminateRun const) when MCRE is finished with
        the current script session.

        """
        self.send_GetNewRun()
        return self.recv_GetNewRun()

    def send_GetNewRun(self):
        self._oprot.writeMessageBegin('GetNewRun', TMessageType.CALL, self._seqid)
        args = GetNewRun_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetNewRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetNewRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetNewRun failed: unknown result")

    def Success(self):
        """
        Signals the end of a successful run.

        """
        self.send_Success()
        self.recv_Success()

    def send_Success(self):
        self._oprot.writeMessageBegin('Success', TMessageType.CALL, self._seqid)
        args = Success_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Success(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Success_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def Failed(self, error):
        """
        Signals the end a failed run.

        Parameters:
         - error: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.  Typically
        such messages include (but only message is required):
           * Error message
           * Stack trace of script files and line numbers.

        """
        self.send_Failed(error)
        self.recv_Failed()

    def send_Failed(self, error):
        self._oprot.writeMessageBegin('Failed', TMessageType.CALL, self._seqid)
        args = Failed_args()
        args.error = error
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Failed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Failed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def boolGetValue(self, varName):
        """
        retrieves the current value of the variable

        Parameters:
         - varName

        """
        self.send_boolGetValue(varName)
        return self.recv_boolGetValue()

    def send_boolGetValue(self, varName):
        self._oprot.writeMessageBegin('boolGetValue', TMessageType.CALL, self._seqid)
        args = boolGetValue_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "boolGetValue failed: unknown result")

    def boolSetValue(self, varName, boolVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - boolVal

        """
        self.send_boolSetValue(varName, boolVal)
        self.recv_boolSetValue()

    def send_boolSetValue(self, varName, boolVal):
        self._oprot.writeMessageBegin('boolSetValue', TMessageType.CALL, self._seqid)
        args = boolSetValue_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolSetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolSetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def boolToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        self.send_boolToString(varName)
        return self.recv_boolToString()

    def send_boolToString(self, varName):
        self._oprot.writeMessageBegin('boolToString', TMessageType.CALL, self._seqid)
        args = boolToString_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "boolToString failed: unknown result")

    def boolArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_boolArrayFromString(varName, index, strVal)
        self.recv_boolArrayFromString()

    def send_boolArrayFromString(self, varName, index, strVal):
        self._oprot.writeMessageBegin('boolArrayFromString', TMessageType.CALL, self._seqid)
        args = boolArrayFromString_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolArrayFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolArrayFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def boolArrayGetValue(self, varName, index):
        """
        retrieves the current value of the variable

        Parameters:
         - varName
         - index

        """
        self.send_boolArrayGetValue(varName, index)
        return self.recv_boolArrayGetValue()

    def send_boolArrayGetValue(self, varName, index):
        self._oprot.writeMessageBegin('boolArrayGetValue', TMessageType.CALL, self._seqid)
        args = boolArrayGetValue_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolArrayGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolArrayGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "boolArrayGetValue failed: unknown result")

    def boolArrayGetValueStr(self, varName, index):
        """
        retrieves the current value of the variable (in string form)

        Parameters:
         - varName
         - index

        """
        self.send_boolArrayGetValueStr(varName, index)
        return self.recv_boolArrayGetValueStr()

    def send_boolArrayGetValueStr(self, varName, index):
        self._oprot.writeMessageBegin('boolArrayGetValueStr', TMessageType.CALL, self._seqid)
        args = boolArrayGetValueStr_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolArrayGetValueStr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolArrayGetValueStr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "boolArrayGetValueStr failed: unknown result")

    def boolArraySetValue(self, varName, index, boolVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - index
         - boolVal

        """
        self.send_boolArraySetValue(varName, index, boolVal)
        self.recv_boolArraySetValue()

    def send_boolArraySetValue(self, varName, index, boolVal):
        self._oprot.writeMessageBegin('boolArraySetValue', TMessageType.CALL, self._seqid)
        args = boolArraySetValue_args()
        args.varName = varName
        args.index = index
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolArraySetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolArraySetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def boolArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        self.send_boolArrayToString(varName, index)
        return self.recv_boolArrayToString()

    def send_boolArrayToString(self, varName, index):
        self._oprot.writeMessageBegin('boolArrayToString', TMessageType.CALL, self._seqid)
        args = boolArrayToString_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_boolArrayToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = boolArrayToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "boolArrayToString failed: unknown result")

    def dblFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        self.send_dblFromString(varName, strVal)
        self.recv_dblFromString()

    def send_dblFromString(self, varName, strVal):
        self._oprot.writeMessageBegin('dblFromString', TMessageType.CALL, self._seqid)
        args = dblFromString_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_dblGetEnumAliases(varName)
        return self.recv_dblGetEnumAliases()

    def send_dblGetEnumAliases(self, varName):
        self._oprot.writeMessageBegin('dblGetEnumAliases', TMessageType.CALL, self._seqid)
        args = dblGetEnumAliases_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetEnumAliases failed: unknown result")

    def dblGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_dblGetEnumValues(varName)
        return self.recv_dblGetEnumValues()

    def send_dblGetEnumValues(self, varName):
        self._oprot.writeMessageBegin('dblGetEnumValues', TMessageType.CALL, self._seqid)
        args = dblGetEnumValues_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetEnumValues failed: unknown result")

    def dblGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        self.send_dblGetFormat(varName)
        return self.recv_dblGetFormat()

    def send_dblGetFormat(self, varName):
        self._oprot.writeMessageBegin('dblGetFormat', TMessageType.CALL, self._seqid)
        args = dblGetFormat_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetFormat failed: unknown result")

    def dblGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        self.send_dblGetHasLowerBound(varName)
        return self.recv_dblGetHasLowerBound()

    def send_dblGetHasLowerBound(self, varName):
        self._oprot.writeMessageBegin('dblGetHasLowerBound', TMessageType.CALL, self._seqid)
        args = dblGetHasLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetHasLowerBound failed: unknown result")

    def dblGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        self.send_dblGetHasUpperBound(varName)
        return self.recv_dblGetHasUpperBound()

    def send_dblGetHasUpperBound(self, varName):
        self._oprot.writeMessageBegin('dblGetHasUpperBound', TMessageType.CALL, self._seqid)
        args = dblGetHasUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetHasUpperBound failed: unknown result")

    def dblGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        self.send_dblGetLowerBound(varName)
        return self.recv_dblGetLowerBound()

    def send_dblGetLowerBound(self, varName):
        self._oprot.writeMessageBegin('dblGetLowerBound', TMessageType.CALL, self._seqid)
        args = dblGetLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetLowerBound failed: unknown result")

    def dblGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        self.send_dblGetUpperBound(varName)
        return self.recv_dblGetUpperBound()

    def send_dblGetUpperBound(self, varName):
        self._oprot.writeMessageBegin('dblGetUpperBound', TMessageType.CALL, self._seqid)
        args = dblGetUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetUpperBound failed: unknown result")

    def dblGetValue(self, varName):
        """
        retrieves the current value of the variable

        Parameters:
         - varName

        """
        self.send_dblGetValue(varName)
        return self.recv_dblGetValue()

    def send_dblGetValue(self, varName):
        self._oprot.writeMessageBegin('dblGetValue', TMessageType.CALL, self._seqid)
        args = dblGetValue_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblGetValue failed: unknown result")

    def dblSetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_dblSetEnumAliases(varName, strVal)
        self.recv_dblSetEnumAliases()

    def send_dblSetEnumAliases(self, varName, strVal):
        self._oprot.writeMessageBegin('dblSetEnumAliases', TMessageType.CALL, self._seqid)
        args = dblSetEnumAliases_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_dblSetEnumValues(varName, strVal)
        self.recv_dblSetEnumValues()

    def send_dblSetEnumValues(self, varName, strVal):
        self._oprot.writeMessageBegin('dblSetEnumValues', TMessageType.CALL, self._seqid)
        args = dblSetEnumValues_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        self.send_dblSetFormat(varName, strVal)
        self.recv_dblSetFormat()

    def send_dblSetFormat(self, varName, strVal):
        self._oprot.writeMessageBegin('dblSetFormat', TMessageType.CALL, self._seqid)
        args = dblSetFormat_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_dblSetHasLowerBound(varName, boolVal)
        self.recv_dblSetHasLowerBound()

    def send_dblSetHasLowerBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('dblSetHasLowerBound', TMessageType.CALL, self._seqid)
        args = dblSetHasLowerBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_dblSetHasUpperBound(varName, boolVal)
        self.recv_dblSetHasUpperBound()

    def send_dblSetHasUpperBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('dblSetHasUpperBound', TMessageType.CALL, self._seqid)
        args = dblSetHasUpperBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetLowerBound(self, varName, dblVal):
        """
        sets the lower bound

        Parameters:
         - varName
         - dblVal

        """
        self.send_dblSetLowerBound(varName, dblVal)
        self.recv_dblSetLowerBound()

    def send_dblSetLowerBound(self, varName, dblVal):
        self._oprot.writeMessageBegin('dblSetLowerBound', TMessageType.CALL, self._seqid)
        args = dblSetLowerBound_args()
        args.varName = varName
        args.dblVal = dblVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetUpperBound(self, varName, dblVal):
        """
        sets the upper bound

        Parameters:
         - varName
         - dblVal

        """
        self.send_dblSetUpperBound(varName, dblVal)
        self.recv_dblSetUpperBound()

    def send_dblSetUpperBound(self, varName, dblVal):
        self._oprot.writeMessageBegin('dblSetUpperBound', TMessageType.CALL, self._seqid)
        args = dblSetUpperBound_args()
        args.varName = varName
        args.dblVal = dblVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblSetValue(self, varName, dblVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - dblVal

        """
        self.send_dblSetValue(varName, dblVal)
        self.recv_dblSetValue()

    def send_dblSetValue(self, varName, dblVal):
        self._oprot.writeMessageBegin('dblSetValue', TMessageType.CALL, self._seqid)
        args = dblSetValue_args()
        args.varName = varName
        args.dblVal = dblVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblSetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblSetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        self.send_dblToString(varName)
        return self.recv_dblToString()

    def send_dblToString(self, varName):
        self._oprot.writeMessageBegin('dblToString', TMessageType.CALL, self._seqid)
        args = dblToString_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblToString failed: unknown result")

    def dblArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_dblArrayFromString(varName, index, strVal)
        self.recv_dblArrayFromString()

    def send_dblArrayFromString(self, varName, index, strVal):
        self._oprot.writeMessageBegin('dblArrayFromString', TMessageType.CALL, self._seqid)
        args = dblArrayFromString_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArrayGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_dblArrayGetEnumAliases(varName)
        return self.recv_dblArrayGetEnumAliases()

    def send_dblArrayGetEnumAliases(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetEnumAliases', TMessageType.CALL, self._seqid)
        args = dblArrayGetEnumAliases_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetEnumAliases failed: unknown result")

    def dblArrayGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_dblArrayGetEnumValues(varName)
        return self.recv_dblArrayGetEnumValues()

    def send_dblArrayGetEnumValues(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetEnumValues', TMessageType.CALL, self._seqid)
        args = dblArrayGetEnumValues_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetEnumValues failed: unknown result")

    def dblArrayGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        self.send_dblArrayGetFormat(varName)
        return self.recv_dblArrayGetFormat()

    def send_dblArrayGetFormat(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetFormat', TMessageType.CALL, self._seqid)
        args = dblArrayGetFormat_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetFormat failed: unknown result")

    def dblArrayGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        self.send_dblArrayGetHasLowerBound(varName)
        return self.recv_dblArrayGetHasLowerBound()

    def send_dblArrayGetHasLowerBound(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetHasLowerBound', TMessageType.CALL, self._seqid)
        args = dblArrayGetHasLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetHasLowerBound failed: unknown result")

    def dblArrayGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        self.send_dblArrayGetHasUpperBound(varName)
        return self.recv_dblArrayGetHasUpperBound()

    def send_dblArrayGetHasUpperBound(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetHasUpperBound', TMessageType.CALL, self._seqid)
        args = dblArrayGetHasUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetHasUpperBound failed: unknown result")

    def dblArrayGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        self.send_dblArrayGetLowerBound(varName)
        return self.recv_dblArrayGetLowerBound()

    def send_dblArrayGetLowerBound(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetLowerBound', TMessageType.CALL, self._seqid)
        args = dblArrayGetLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetLowerBound failed: unknown result")

    def dblArrayGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        self.send_dblArrayGetUpperBound(varName)
        return self.recv_dblArrayGetUpperBound()

    def send_dblArrayGetUpperBound(self, varName):
        self._oprot.writeMessageBegin('dblArrayGetUpperBound', TMessageType.CALL, self._seqid)
        args = dblArrayGetUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetUpperBound failed: unknown result")

    def dblArrayGetValue(self, varName, index):
        """
        retrieves the current value of the variable with the associated index

        Parameters:
         - varName
         - index

        """
        self.send_dblArrayGetValue(varName, index)
        return self.recv_dblArrayGetValue()

    def send_dblArrayGetValue(self, varName, index):
        self._oprot.writeMessageBegin('dblArrayGetValue', TMessageType.CALL, self._seqid)
        args = dblArrayGetValue_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayGetValue failed: unknown result")

    def dblArraySetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_dblArraySetEnumAliases(varName, strVal)
        self.recv_dblArraySetEnumAliases()

    def send_dblArraySetEnumAliases(self, varName, strVal):
        self._oprot.writeMessageBegin('dblArraySetEnumAliases', TMessageType.CALL, self._seqid)
        args = dblArraySetEnumAliases_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_dblArraySetEnumValues(varName, strVal)
        self.recv_dblArraySetEnumValues()

    def send_dblArraySetEnumValues(self, varName, strVal):
        self._oprot.writeMessageBegin('dblArraySetEnumValues', TMessageType.CALL, self._seqid)
        args = dblArraySetEnumValues_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        self.send_dblArraySetFormat(varName, strVal)
        self.recv_dblArraySetFormat()

    def send_dblArraySetFormat(self, varName, strVal):
        self._oprot.writeMessageBegin('dblArraySetFormat', TMessageType.CALL, self._seqid)
        args = dblArraySetFormat_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_dblArraySetHasLowerBound(varName, boolVal)
        self.recv_dblArraySetHasLowerBound()

    def send_dblArraySetHasLowerBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('dblArraySetHasLowerBound', TMessageType.CALL, self._seqid)
        args = dblArraySetHasLowerBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_dblArraySetHasUpperBound(varName, boolVal)
        self.recv_dblArraySetHasUpperBound()

    def send_dblArraySetHasUpperBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('dblArraySetHasUpperBound', TMessageType.CALL, self._seqid)
        args = dblArraySetHasUpperBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetLowerBound(self, varName, dblVal):
        """
        sets the lower bound

        Parameters:
         - varName
         - dblVal

        """
        self.send_dblArraySetLowerBound(varName, dblVal)
        self.recv_dblArraySetLowerBound()

    def send_dblArraySetLowerBound(self, varName, dblVal):
        self._oprot.writeMessageBegin('dblArraySetLowerBound', TMessageType.CALL, self._seqid)
        args = dblArraySetLowerBound_args()
        args.varName = varName
        args.dblVal = dblVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetUpperBound(self, varName, dblVal):
        """
        sets the upper bound

        Parameters:
         - varName
         - dblVal

        """
        self.send_dblArraySetUpperBound(varName, dblVal)
        self.recv_dblArraySetUpperBound()

    def send_dblArraySetUpperBound(self, varName, dblVal):
        self._oprot.writeMessageBegin('dblArraySetUpperBound', TMessageType.CALL, self._seqid)
        args = dblArraySetUpperBound_args()
        args.varName = varName
        args.dblVal = dblVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArraySetValue(self, varName, index, dblVal):
        """
        sets the value for the variable

        Parameters:
         - varName
         - index
         - dblVal

        """
        self.send_dblArraySetValue(varName, index, dblVal)
        self.recv_dblArraySetValue()

    def send_dblArraySetValue(self, varName, index, dblVal):
        self._oprot.writeMessageBegin('dblArraySetValue', TMessageType.CALL, self._seqid)
        args = dblArraySetValue_args()
        args.varName = varName
        args.index = index
        args.dblVal = dblVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArraySetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArraySetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def dblArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        self.send_dblArrayToString(varName, index)
        return self.recv_dblArrayToString()

    def send_dblArrayToString(self, varName, index):
        self._oprot.writeMessageBegin('dblArrayToString', TMessageType.CALL, self._seqid)
        args = dblArrayToString_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dblArrayToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dblArrayToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "dblArrayToString failed: unknown result")

    def longFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        self.send_longFromString(varName, strVal)
        self.recv_longFromString()

    def send_longFromString(self, varName, strVal):
        self._oprot.writeMessageBegin('longFromString', TMessageType.CALL, self._seqid)
        args = longFromString_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_longGetEnumAliases(varName)
        return self.recv_longGetEnumAliases()

    def send_longGetEnumAliases(self, varName):
        self._oprot.writeMessageBegin('longGetEnumAliases', TMessageType.CALL, self._seqid)
        args = longGetEnumAliases_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetEnumAliases failed: unknown result")

    def longGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_longGetEnumValues(varName)
        return self.recv_longGetEnumValues()

    def send_longGetEnumValues(self, varName):
        self._oprot.writeMessageBegin('longGetEnumValues', TMessageType.CALL, self._seqid)
        args = longGetEnumValues_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetEnumValues failed: unknown result")

    def longGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        self.send_longGetFormat(varName)
        return self.recv_longGetFormat()

    def send_longGetFormat(self, varName):
        self._oprot.writeMessageBegin('longGetFormat', TMessageType.CALL, self._seqid)
        args = longGetFormat_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetFormat failed: unknown result")

    def longGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        self.send_longGetHasLowerBound(varName)
        return self.recv_longGetHasLowerBound()

    def send_longGetHasLowerBound(self, varName):
        self._oprot.writeMessageBegin('longGetHasLowerBound', TMessageType.CALL, self._seqid)
        args = longGetHasLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetHasLowerBound failed: unknown result")

    def longGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        self.send_longGetHasUpperBound(varName)
        return self.recv_longGetHasUpperBound()

    def send_longGetHasUpperBound(self, varName):
        self._oprot.writeMessageBegin('longGetHasUpperBound', TMessageType.CALL, self._seqid)
        args = longGetHasUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetHasUpperBound failed: unknown result")

    def longGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        self.send_longGetLowerBound(varName)
        return self.recv_longGetLowerBound()

    def send_longGetLowerBound(self, varName):
        self._oprot.writeMessageBegin('longGetLowerBound', TMessageType.CALL, self._seqid)
        args = longGetLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetLowerBound failed: unknown result")

    def longGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        self.send_longGetUpperBound(varName)
        return self.recv_longGetUpperBound()

    def send_longGetUpperBound(self, varName):
        self._oprot.writeMessageBegin('longGetUpperBound', TMessageType.CALL, self._seqid)
        args = longGetUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetUpperBound failed: unknown result")

    def longGetValue(self, varName):
        """
        retrieves the current value of the variable

        Parameters:
         - varName

        """
        self.send_longGetValue(varName)
        return self.recv_longGetValue()

    def send_longGetValue(self, varName):
        self._oprot.writeMessageBegin('longGetValue', TMessageType.CALL, self._seqid)
        args = longGetValue_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longGetValue failed: unknown result")

    def longSetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_longSetEnumAliases(varName, strVal)
        self.recv_longSetEnumAliases()

    def send_longSetEnumAliases(self, varName, strVal):
        self._oprot.writeMessageBegin('longSetEnumAliases', TMessageType.CALL, self._seqid)
        args = longSetEnumAliases_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_longSetEnumValues(varName, strVal)
        self.recv_longSetEnumValues()

    def send_longSetEnumValues(self, varName, strVal):
        self._oprot.writeMessageBegin('longSetEnumValues', TMessageType.CALL, self._seqid)
        args = longSetEnumValues_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        self.send_longSetFormat(varName, strVal)
        self.recv_longSetFormat()

    def send_longSetFormat(self, varName, strVal):
        self._oprot.writeMessageBegin('longSetFormat', TMessageType.CALL, self._seqid)
        args = longSetFormat_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_longSetHasLowerBound(varName, boolVal)
        self.recv_longSetHasLowerBound()

    def send_longSetHasLowerBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('longSetHasLowerBound', TMessageType.CALL, self._seqid)
        args = longSetHasLowerBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_longSetHasUpperBound(varName, boolVal)
        self.recv_longSetHasUpperBound()

    def send_longSetHasUpperBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('longSetHasUpperBound', TMessageType.CALL, self._seqid)
        args = longSetHasUpperBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetLowerBound(self, varName, value):
        """
        sets the lower bound

        Parameters:
         - varName
         - value

        """
        self.send_longSetLowerBound(varName, value)
        self.recv_longSetLowerBound()

    def send_longSetLowerBound(self, varName, value):
        self._oprot.writeMessageBegin('longSetLowerBound', TMessageType.CALL, self._seqid)
        args = longSetLowerBound_args()
        args.varName = varName
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetUpperBound(self, varName, value):
        """
        sets the upper bound

        Parameters:
         - varName
         - value

        """
        self.send_longSetUpperBound(varName, value)
        self.recv_longSetUpperBound()

    def send_longSetUpperBound(self, varName, value):
        self._oprot.writeMessageBegin('longSetUpperBound', TMessageType.CALL, self._seqid)
        args = longSetUpperBound_args()
        args.varName = varName
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longSetValue(self, varName, value):
        """
        sets the value for the variable

        Parameters:
         - varName
         - value

        """
        self.send_longSetValue(varName, value)
        self.recv_longSetValue()

    def send_longSetValue(self, varName, value):
        self._oprot.writeMessageBegin('longSetValue', TMessageType.CALL, self._seqid)
        args = longSetValue_args()
        args.varName = varName
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longSetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longSetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        self.send_longToString(varName)
        return self.recv_longToString()

    def send_longToString(self, varName):
        self._oprot.writeMessageBegin('longToString', TMessageType.CALL, self._seqid)
        args = longToString_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longToString failed: unknown result")

    def longArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_longArrayFromString(varName, index, strVal)
        self.recv_longArrayFromString()

    def send_longArrayFromString(self, varName, index, strVal):
        self._oprot.writeMessageBegin('longArrayFromString', TMessageType.CALL, self._seqid)
        args = longArrayFromString_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArrayGetEnumAliases(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_longArrayGetEnumAliases(varName)
        return self.recv_longArrayGetEnumAliases()

    def send_longArrayGetEnumAliases(self, varName):
        self._oprot.writeMessageBegin('longArrayGetEnumAliases', TMessageType.CALL, self._seqid)
        args = longArrayGetEnumAliases_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetEnumAliases failed: unknown result")

    def longArrayGetEnumValues(self, varName):
        """
        An interface function for the enumeration array

        Parameters:
         - varName

        """
        self.send_longArrayGetEnumValues(varName)
        return self.recv_longArrayGetEnumValues()

    def send_longArrayGetEnumValues(self, varName):
        self._oprot.writeMessageBegin('longArrayGetEnumValues', TMessageType.CALL, self._seqid)
        args = longArrayGetEnumValues_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetEnumValues failed: unknown result")

    def longArrayGetFormat(self, varName):
        """
        retrieves the format of the variable

        Parameters:
         - varName

        """
        self.send_longArrayGetFormat(varName)
        return self.recv_longArrayGetFormat()

    def send_longArrayGetFormat(self, varName):
        self._oprot.writeMessageBegin('longArrayGetFormat', TMessageType.CALL, self._seqid)
        args = longArrayGetFormat_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetFormat failed: unknown result")

    def longArrayGetHasLowerBound(self, varName):
        """
        retrieves the hasLowerBound flag

        Parameters:
         - varName

        """
        self.send_longArrayGetHasLowerBound(varName)
        return self.recv_longArrayGetHasLowerBound()

    def send_longArrayGetHasLowerBound(self, varName):
        self._oprot.writeMessageBegin('longArrayGetHasLowerBound', TMessageType.CALL, self._seqid)
        args = longArrayGetHasLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetHasLowerBound failed: unknown result")

    def longArrayGetHasUpperBound(self, varName):
        """
        retrieves the hasUpperBound flag

        Parameters:
         - varName

        """
        self.send_longArrayGetHasUpperBound(varName)
        return self.recv_longArrayGetHasUpperBound()

    def send_longArrayGetHasUpperBound(self, varName):
        self._oprot.writeMessageBegin('longArrayGetHasUpperBound', TMessageType.CALL, self._seqid)
        args = longArrayGetHasUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetHasUpperBound failed: unknown result")

    def longArrayGetLowerBound(self, varName):
        """
        retrieves the current lower bound value

        Parameters:
         - varName

        """
        self.send_longArrayGetLowerBound(varName)
        return self.recv_longArrayGetLowerBound()

    def send_longArrayGetLowerBound(self, varName):
        self._oprot.writeMessageBegin('longArrayGetLowerBound', TMessageType.CALL, self._seqid)
        args = longArrayGetLowerBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetLowerBound failed: unknown result")

    def longArrayGetUpperBound(self, varName):
        """
        retrieves the current upper bound value

        Parameters:
         - varName

        """
        self.send_longArrayGetUpperBound(varName)
        return self.recv_longArrayGetUpperBound()

    def send_longArrayGetUpperBound(self, varName):
        self._oprot.writeMessageBegin('longArrayGetUpperBound', TMessageType.CALL, self._seqid)
        args = longArrayGetUpperBound_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetUpperBound failed: unknown result")

    def longArrayGetValue(self, varName, index):
        """
        retrieves the current value of the variable with the associated index

        Parameters:
         - varName
         - index

        """
        self.send_longArrayGetValue(varName, index)
        return self.recv_longArrayGetValue()

    def send_longArrayGetValue(self, varName, index):
        self._oprot.writeMessageBegin('longArrayGetValue', TMessageType.CALL, self._seqid)
        args = longArrayGetValue_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayGetValue failed: unknown result")

    def longArraySetEnumAliases(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration aliases list with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_longArraySetEnumAliases(varName, strVal)
        self.recv_longArraySetEnumAliases()

    def send_longArraySetEnumAliases(self, varName, strVal):
        self._oprot.writeMessageBegin('longArraySetEnumAliases', TMessageType.CALL, self._seqid)
        args = longArraySetEnumAliases_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetEnumValues(self, varName, strVal):
        """
        takes a comma seperated string of values and fills the enumeration List with values.

        Parameters:
         - varName
         - strVal

        """
        self.send_longArraySetEnumValues(varName, strVal)
        self.recv_longArraySetEnumValues()

    def send_longArraySetEnumValues(self, varName, strVal):
        self._oprot.writeMessageBegin('longArraySetEnumValues', TMessageType.CALL, self._seqid)
        args = longArraySetEnumValues_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetFormat(self, varName, strVal):
        """
        sets the format options

        Parameters:
         - varName
         - strVal

        """
        self.send_longArraySetFormat(varName, strVal)
        self.recv_longArraySetFormat()

    def send_longArraySetFormat(self, varName, strVal):
        self._oprot.writeMessageBegin('longArraySetFormat', TMessageType.CALL, self._seqid)
        args = longArraySetFormat_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetFormat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetFormat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetHasLowerBound(self, varName, boolVal):
        """
        sets the hasLowerBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_longArraySetHasLowerBound(varName, boolVal)
        self.recv_longArraySetHasLowerBound()

    def send_longArraySetHasLowerBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('longArraySetHasLowerBound', TMessageType.CALL, self._seqid)
        args = longArraySetHasLowerBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetHasLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetHasLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetHasUpperBound(self, varName, boolVal):
        """
        sets the hasUpperBound flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_longArraySetHasUpperBound(varName, boolVal)
        self.recv_longArraySetHasUpperBound()

    def send_longArraySetHasUpperBound(self, varName, boolVal):
        self._oprot.writeMessageBegin('longArraySetHasUpperBound', TMessageType.CALL, self._seqid)
        args = longArraySetHasUpperBound_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetHasUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetHasUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetLowerBound(self, varName, value):
        """
        sets the lower bound

        Parameters:
         - varName
         - value

        """
        self.send_longArraySetLowerBound(varName, value)
        self.recv_longArraySetLowerBound()

    def send_longArraySetLowerBound(self, varName, value):
        self._oprot.writeMessageBegin('longArraySetLowerBound', TMessageType.CALL, self._seqid)
        args = longArraySetLowerBound_args()
        args.varName = varName
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetUpperBound(self, varName, value):
        """
        sets the upper bound

        Parameters:
         - varName
         - value

        """
        self.send_longArraySetUpperBound(varName, value)
        self.recv_longArraySetUpperBound()

    def send_longArraySetUpperBound(self, varName, value):
        self._oprot.writeMessageBegin('longArraySetUpperBound', TMessageType.CALL, self._seqid)
        args = longArraySetUpperBound_args()
        args.varName = varName
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArraySetValue(self, varName, index, value):
        """
        sets the value for the variable

        Parameters:
         - varName
         - index
         - value

        """
        self.send_longArraySetValue(varName, index, value)
        self.recv_longArraySetValue()

    def send_longArraySetValue(self, varName, index, value):
        self._oprot.writeMessageBegin('longArraySetValue', TMessageType.CALL, self._seqid)
        args = longArraySetValue_args()
        args.varName = varName
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArraySetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArraySetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def longArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        self.send_longArrayToString(varName, index)
        return self.recv_longArrayToString()

    def send_longArrayToString(self, varName, index):
        self._oprot.writeMessageBegin('longArrayToString', TMessageType.CALL, self._seqid)
        args = longArrayToString_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_longArrayToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = longArrayToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "longArrayToString failed: unknown result")

    def fileFromFile(self, varName, fileName):
        """
        Sets the filename and then reads from disk.

        Parameters:
         - varName
         - fileName

        """
        self.send_fileFromFile(varName, fileName)
        self.recv_fileFromFile()

    def send_fileFromFile(self, varName, fileName):
        self._oprot.writeMessageBegin('fileFromFile', TMessageType.CALL, self._seqid)
        args = fileFromFile_args()
        args.varName = varName
        args.fileName = fileName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileFromFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileFromFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        self.send_fileFromString(varName, strVal)
        self.recv_fileFromString()

    def send_fileFromString(self, varName, strVal):
        self._oprot.writeMessageBegin('fileFromString', TMessageType.CALL, self._seqid)
        args = fileFromString_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileGetBaseName(self, varName):
        """
        gets the base name of the file

        Parameters:
         - varName

        """
        self.send_fileGetBaseName(varName)
        return self.recv_fileGetBaseName()

    def send_fileGetBaseName(self, varName):
        self._oprot.writeMessageBegin('fileGetBaseName', TMessageType.CALL, self._seqid)
        args = fileGetBaseName_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetBaseName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetBaseName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetBaseName failed: unknown result")

    def fileGetContents(self, varName):
        """
        retrieves the contents of the file

        Parameters:
         - varName

        """
        self.send_fileGetContents(varName)
        return self.recv_fileGetContents()

    def send_fileGetContents(self, varName):
        self._oprot.writeMessageBegin('fileGetContents', TMessageType.CALL, self._seqid)
        args = fileGetContents_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetContents failed: unknown result")

    def fileGetFileExtension(self, varName):
        """
        Returns the extension of the file that this object represents

        Parameters:
         - varName

        """
        self.send_fileGetFileExtension(varName)
        return self.recv_fileGetFileExtension()

    def send_fileGetFileExtension(self, varName):
        self._oprot.writeMessageBegin('fileGetFileExtension', TMessageType.CALL, self._seqid)
        args = fileGetFileExtension_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetFileExtension(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetFileExtension_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetFileExtension failed: unknown result")

    def fileGetIsBinary(self, varName):
        """
        Tells whether or not the the file is binary.

        Parameters:
         - varName

        """
        self.send_fileGetIsBinary(varName)
        return self.recv_fileGetIsBinary()

    def send_fileGetIsBinary(self, varName):
        self._oprot.writeMessageBegin('fileGetIsBinary', TMessageType.CALL, self._seqid)
        args = fileGetIsBinary_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetIsBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetIsBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetIsBinary failed: unknown result")

    def fileGetMimeType(self, varName):
        """
        Get the MIME type for the file

        Parameters:
         - varName

        """
        self.send_fileGetMimeType(varName)
        return self.recv_fileGetMimeType()

    def send_fileGetMimeType(self, varName):
        self._oprot.writeMessageBegin('fileGetMimeType', TMessageType.CALL, self._seqid)
        args = fileGetMimeType_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetMimeType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetMimeType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetMimeType failed: unknown result")

    def fileGetName(self, varName):
        """
        retrieves the name of the file

        Parameters:
         - varName

        """
        self.send_fileGetName(varName)
        return self.recv_fileGetName()

    def send_fileGetName(self, varName):
        self._oprot.writeMessageBegin('fileGetName', TMessageType.CALL, self._seqid)
        args = fileGetName_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetName failed: unknown result")

    def fileGetNameCoded(self, varName):
        """
        retrieves the name of the file in coded form (without $variables replaced)

        Parameters:
         - varName

        """
        self.send_fileGetNameCoded(varName)
        return self.recv_fileGetNameCoded()

    def send_fileGetNameCoded(self, varName):
        self._oprot.writeMessageBegin('fileGetNameCoded', TMessageType.CALL, self._seqid)
        args = fileGetNameCoded_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileGetNameCoded(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileGetNameCoded_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileGetNameCoded failed: unknown result")

    def fileHasChanged(self, varName):
        """
        checks to see if the file has changed since the last time getContents() was called

        Parameters:
         - varName

        """
        self.send_fileHasChanged(varName)
        return self.recv_fileHasChanged()

    def send_fileHasChanged(self, varName):
        self._oprot.writeMessageBegin('fileHasChanged', TMessageType.CALL, self._seqid)
        args = fileHasChanged_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileHasChanged(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileHasChanged_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileHasChanged failed: unknown result")

    def fileMarkAsRead(self, varName):
        """
        call this function after you manually get the contents of the file.

        Parameters:
         - varName

        """
        self.send_fileMarkAsRead(varName)
        self.recv_fileMarkAsRead()

    def send_fileMarkAsRead(self, varName):
        self._oprot.writeMessageBegin('fileMarkAsRead', TMessageType.CALL, self._seqid)
        args = fileMarkAsRead_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileMarkAsRead(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileMarkAsRead_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileSetBaseName(self, varName, name):
        """
        sets the base name of the file

        Parameters:
         - varName
         - name

        """
        self.send_fileSetBaseName(varName, name)
        self.recv_fileSetBaseName()

    def send_fileSetBaseName(self, varName, name):
        self._oprot.writeMessageBegin('fileSetBaseName', TMessageType.CALL, self._seqid)
        args = fileSetBaseName_args()
        args.varName = varName
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileSetBaseName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileSetBaseName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileSetContents(self, varName, contents):
        """
        sets the contents of the file.

        Parameters:
         - varName
         - contents

        """
        self.send_fileSetContents(varName, contents)
        self.recv_fileSetContents()

    def send_fileSetContents(self, varName, contents):
        self._oprot.writeMessageBegin('fileSetContents', TMessageType.CALL, self._seqid)
        args = fileSetContents_args()
        args.varName = varName
        args.contents = contents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileSetContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileSetContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileSetFileExtension(self, varName, extension):
        """
        Sets the extension of the file that this object represents.

        Parameters:
         - varName
         - extension

        """
        self.send_fileSetFileExtension(varName, extension)
        self.recv_fileSetFileExtension()

    def send_fileSetFileExtension(self, varName, extension):
        self._oprot.writeMessageBegin('fileSetFileExtension', TMessageType.CALL, self._seqid)
        args = fileSetFileExtension_args()
        args.varName = varName
        args.extension = extension
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileSetFileExtension(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileSetFileExtension_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileSetIsBinary(self, varName, boolVal):
        """
        Forces this file to be binary or not.

        Parameters:
         - varName
         - boolVal

        """
        self.send_fileSetIsBinary(varName, boolVal)
        self.recv_fileSetIsBinary()

    def send_fileSetIsBinary(self, varName, boolVal):
        self._oprot.writeMessageBegin('fileSetIsBinary', TMessageType.CALL, self._seqid)
        args = fileSetIsBinary_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileSetIsBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileSetIsBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileSetMimeType(self, varName, mimeType):
        """
        Set the MIME type for the file

        Parameters:
         - varName
         - mimeType

        """
        self.send_fileSetMimeType(varName, mimeType)
        self.recv_fileSetMimeType()

    def send_fileSetMimeType(self, varName, mimeType):
        self._oprot.writeMessageBegin('fileSetMimeType', TMessageType.CALL, self._seqid)
        args = fileSetMimeType_args()
        args.varName = varName
        args.mimeType = mimeType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileSetMimeType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileSetMimeType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileSetName(self, varName, strVal):
        """
        sets the name of the file

        Parameters:
         - varName
         - strVal

        """
        self.send_fileSetName(varName, strVal)
        self.recv_fileSetName()

    def send_fileSetName(self, varName, strVal):
        self._oprot.writeMessageBegin('fileSetName', TMessageType.CALL, self._seqid)
        args = fileSetName_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileSetName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileSetName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileToFile(self, varName, strVal):
        """
        sets the filename and then writes the file to disk.

        Parameters:
         - varName
         - strVal

        """
        self.send_fileToFile(varName, strVal)
        self.recv_fileToFile()

    def send_fileToFile(self, varName, strVal):
        self._oprot.writeMessageBegin('fileToFile', TMessageType.CALL, self._seqid)
        args = fileToFile_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileToFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileToFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        self.send_fileToString(varName)
        return self.recv_fileToString()

    def send_fileToString(self, varName):
        self._oprot.writeMessageBegin('fileToString', TMessageType.CALL, self._seqid)
        args = fileToString_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileToString failed: unknown result")

    def fileArrayFromFile(self, varName, index, fileName):
        """
        Sets the filename and then reads from disk.

        Parameters:
         - varName
         - index
         - fileName

        """
        self.send_fileArrayFromFile(varName, index, fileName)
        self.recv_fileArrayFromFile()

    def send_fileArrayFromFile(self, varName, index, fileName):
        self._oprot.writeMessageBegin('fileArrayFromFile', TMessageType.CALL, self._seqid)
        args = fileArrayFromFile_args()
        args.varName = varName
        args.index = index
        args.fileName = fileName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayFromFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayFromFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArrayFromString(self, varName, index, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_fileArrayFromString(varName, index, strVal)
        self.recv_fileArrayFromString()

    def send_fileArrayFromString(self, varName, index, strVal):
        self._oprot.writeMessageBegin('fileArrayFromString', TMessageType.CALL, self._seqid)
        args = fileArrayFromString_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArrayGetBaseName(self, varName):
        """
        gets the base name of the file

        Parameters:
         - varName

        """
        self.send_fileArrayGetBaseName(varName)
        return self.recv_fileArrayGetBaseName()

    def send_fileArrayGetBaseName(self, varName):
        self._oprot.writeMessageBegin('fileArrayGetBaseName', TMessageType.CALL, self._seqid)
        args = fileArrayGetBaseName_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetBaseName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetBaseName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetBaseName failed: unknown result")

    def fileArrayGetContents(self, varName, index):
        """
        retrieves the contents of the file

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayGetContents(varName, index)
        return self.recv_fileArrayGetContents()

    def send_fileArrayGetContents(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayGetContents', TMessageType.CALL, self._seqid)
        args = fileArrayGetContents_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetContents failed: unknown result")

    def fileArrayGetFileExtension(self, varName, index):
        """
        Returns the extension of the file that this object represents

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayGetFileExtension(varName, index)
        return self.recv_fileArrayGetFileExtension()

    def send_fileArrayGetFileExtension(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayGetFileExtension', TMessageType.CALL, self._seqid)
        args = fileArrayGetFileExtension_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetFileExtension(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetFileExtension_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetFileExtension failed: unknown result")

    def fileArrayGetIsBinary(self, varName):
        """
        Tells whether or not the the file is binary.

        Parameters:
         - varName

        """
        self.send_fileArrayGetIsBinary(varName)
        return self.recv_fileArrayGetIsBinary()

    def send_fileArrayGetIsBinary(self, varName):
        self._oprot.writeMessageBegin('fileArrayGetIsBinary', TMessageType.CALL, self._seqid)
        args = fileArrayGetIsBinary_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetIsBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetIsBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetIsBinary failed: unknown result")

    def fileArrayGetMimeType(self, varName):
        """
        Get the MIME type for the files

        Parameters:
         - varName

        """
        self.send_fileArrayGetMimeType(varName)
        return self.recv_fileArrayGetMimeType()

    def send_fileArrayGetMimeType(self, varName):
        self._oprot.writeMessageBegin('fileArrayGetMimeType', TMessageType.CALL, self._seqid)
        args = fileArrayGetMimeType_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetMimeType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetMimeType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetMimeType failed: unknown result")

    def fileArrayGetName(self, varName, index):
        """
        retrieves the name of the file

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayGetName(varName, index)
        return self.recv_fileArrayGetName()

    def send_fileArrayGetName(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayGetName', TMessageType.CALL, self._seqid)
        args = fileArrayGetName_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetName failed: unknown result")

    def fileArrayGetNameCoded(self, varName, index):
        """
        retrieves the name of the file in coded form (without $variables replaced)

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayGetNameCoded(varName, index)
        return self.recv_fileArrayGetNameCoded()

    def send_fileArrayGetNameCoded(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayGetNameCoded', TMessageType.CALL, self._seqid)
        args = fileArrayGetNameCoded_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayGetNameCoded(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayGetNameCoded_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayGetNameCoded failed: unknown result")

    def fileArrayHasChanged(self, varName, index):
        """
        checks to see if the file has changed since the last time getContents() was called

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayHasChanged(varName, index)
        return self.recv_fileArrayHasChanged()

    def send_fileArrayHasChanged(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayHasChanged', TMessageType.CALL, self._seqid)
        args = fileArrayHasChanged_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayHasChanged(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayHasChanged_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayHasChanged failed: unknown result")

    def fileArrayMarkAsRead(self, varName, index):
        """
        call this function after you manually get the contents of the file.

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayMarkAsRead(varName, index)
        self.recv_fileArrayMarkAsRead()

    def send_fileArrayMarkAsRead(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayMarkAsRead', TMessageType.CALL, self._seqid)
        args = fileArrayMarkAsRead_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayMarkAsRead(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayMarkAsRead_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArraySetBaseName(self, varName, name):
        """
        sets the base name of the file

        Parameters:
         - varName
         - name

        """
        self.send_fileArraySetBaseName(varName, name)
        self.recv_fileArraySetBaseName()

    def send_fileArraySetBaseName(self, varName, name):
        self._oprot.writeMessageBegin('fileArraySetBaseName', TMessageType.CALL, self._seqid)
        args = fileArraySetBaseName_args()
        args.varName = varName
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArraySetBaseName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArraySetBaseName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArraySetContents(self, varName, index, contents):
        """
        sets the contents of the file.

        Parameters:
         - varName
         - index
         - contents

        """
        self.send_fileArraySetContents(varName, index, contents)
        self.recv_fileArraySetContents()

    def send_fileArraySetContents(self, varName, index, contents):
        self._oprot.writeMessageBegin('fileArraySetContents', TMessageType.CALL, self._seqid)
        args = fileArraySetContents_args()
        args.varName = varName
        args.index = index
        args.contents = contents
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArraySetContents(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArraySetContents_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArraySetFileExtension(self, varName, index, extension):
        """
        Sets the extension of the file that this object represents.

        Parameters:
         - varName
         - index
         - extension

        """
        self.send_fileArraySetFileExtension(varName, index, extension)
        self.recv_fileArraySetFileExtension()

    def send_fileArraySetFileExtension(self, varName, index, extension):
        self._oprot.writeMessageBegin('fileArraySetFileExtension', TMessageType.CALL, self._seqid)
        args = fileArraySetFileExtension_args()
        args.varName = varName
        args.index = index
        args.extension = extension
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArraySetFileExtension(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArraySetFileExtension_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArraySetIsBinary(self, varName, boolVal):
        """
        Forces this file to be binary or not.

        Parameters:
         - varName
         - boolVal

        """
        self.send_fileArraySetIsBinary(varName, boolVal)
        self.recv_fileArraySetIsBinary()

    def send_fileArraySetIsBinary(self, varName, boolVal):
        self._oprot.writeMessageBegin('fileArraySetIsBinary', TMessageType.CALL, self._seqid)
        args = fileArraySetIsBinary_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArraySetIsBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArraySetIsBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArraySetMimeType(self, varName, mimeType):
        """
        Set the MIME type for the files

        Parameters:
         - varName
         - mimeType

        """
        self.send_fileArraySetMimeType(varName, mimeType)
        self.recv_fileArraySetMimeType()

    def send_fileArraySetMimeType(self, varName, mimeType):
        self._oprot.writeMessageBegin('fileArraySetMimeType', TMessageType.CALL, self._seqid)
        args = fileArraySetMimeType_args()
        args.varName = varName
        args.mimeType = mimeType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArraySetMimeType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArraySetMimeType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArraySetName(self, varName, index, strVal):
        """
        sets the name of the file

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_fileArraySetName(varName, index, strVal)
        self.recv_fileArraySetName()

    def send_fileArraySetName(self, varName, index, strVal):
        self._oprot.writeMessageBegin('fileArraySetName', TMessageType.CALL, self._seqid)
        args = fileArraySetName_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArraySetName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArraySetName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArrayToFile(self, varName, index, strVal):
        """
        sets the filename and then writes the file to disk.

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_fileArrayToFile(varName, index, strVal)
        self.recv_fileArrayToFile()

    def send_fileArrayToFile(self, varName, index, strVal):
        self._oprot.writeMessageBegin('fileArrayToFile', TMessageType.CALL, self._seqid)
        args = fileArrayToFile_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayToFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayToFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def fileArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        self.send_fileArrayToString(varName, index)
        return self.recv_fileArrayToString()

    def send_fileArrayToString(self, varName, index):
        self._oprot.writeMessageBegin('fileArrayToString', TMessageType.CALL, self._seqid)
        args = fileArrayToString_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fileArrayToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fileArrayToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fileArrayToString failed: unknown result")

    def newPHXRowFieldFile(self, mode):
        """
        creates a new PHXRowFieldFile object

        Parameters:
         - mode

        """
        self.send_newPHXRowFieldFile(mode)
        return self.recv_newPHXRowFieldFile()

    def send_newPHXRowFieldFile(self, mode):
        self._oprot.writeMessageBegin('newPHXRowFieldFile', TMessageType.CALL, self._seqid)
        args = newPHXRowFieldFile_args()
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_newPHXRowFieldFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = newPHXRowFieldFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "newPHXRowFieldFile failed: unknown result")

    def rffClearMarks(self, key):
        """
        Removes effects of any previous markAsBeginning() or markAsEnd() calls

        Parameters:
         - key

        """
        self.send_rffClearMarks(key)
        self.recv_rffClearMarks()

    def send_rffClearMarks(self, key):
        self._oprot.writeMessageBegin('rffClearMarks', TMessageType.CALL, self._seqid)
        args = rffClearMarks_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffClearMarks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffClearMarks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffClose(self, key):
        """
        Closes the input file and frees up resources associated w/ this RowFieldFile.

        Parameters:
         - key

        """
        self.send_rffClose(key)
        self.recv_rffClose()

    def send_rffClose(self, key):
        self._oprot.writeMessageBegin('rffClose', TMessageType.CALL, self._seqid)
        args = rffClose_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffClose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffClose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffDelete(self, key):
        """
        deletes a PHXRowFieldFile object

        Parameters:
         - key

        """
        self.send_rffDelete(key)
        self.recv_rffDelete()

    def send_rffDelete(self, key):
        self._oprot.writeMessageBegin('rffDelete', TMessageType.CALL, self._seqid)
        args = rffDelete_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffDelete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffDelete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffGenerate(self, key):
        """
        If mode is GENERATE, this function actually writes the output file to disk.

        Parameters:
         - key

        """
        self.send_rffGenerate(key)
        self.recv_rffGenerate()

    def send_rffGenerate(self, key):
        self._oprot.writeMessageBegin('rffGenerate', TMessageType.CALL, self._seqid)
        args = rffGenerate_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffGenerate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffGenerate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffMarkAsBeginning(self, key, find, occurrence, offset, regex):
        """
        Searches for the specified string and makes the row where the string was found act as row 1 for all subsequent
        calls until another markAsBeginning or clearMarks call.

        Parameters:
         - key
         - find
         - occurrence
         - offset
         - regex

        """
        self.send_rffMarkAsBeginning(key, find, occurrence, offset, regex)
        self.recv_rffMarkAsBeginning()

    def send_rffMarkAsBeginning(self, key, find, occurrence, offset, regex):
        self._oprot.writeMessageBegin('rffMarkAsBeginning', TMessageType.CALL, self._seqid)
        args = rffMarkAsBeginning_args()
        args.key = key
        args.find = find
        args.occurrence = occurrence
        args.offset = offset
        args.regex = regex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffMarkAsBeginning(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffMarkAsBeginning_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffMarkAsEnd(self, key, find, occurrence, offset, regex):
        """
        Searches for the specified string and makes the row where the string was found act as row -1 (end of file) for
        all subsequent calls until another markAsEnd or clearMarks call.

        Parameters:
         - key
         - find
         - occurrence
         - offset
         - regex

        """
        self.send_rffMarkAsEnd(key, find, occurrence, offset, regex)
        self.recv_rffMarkAsEnd()

    def send_rffMarkAsEnd(self, key, find, occurrence, offset, regex):
        self._oprot.writeMessageBegin('rffMarkAsEnd', TMessageType.CALL, self._seqid)
        args = rffMarkAsEnd_args()
        args.key = key
        args.find = find
        args.occurrence = occurrence
        args.offset = offset
        args.regex = regex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffMarkAsEnd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffMarkAsEnd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffReadDouble(self, key, row, field):
        """
        Reads a value out of the input file.

        Parameters:
         - key
         - row
         - field

        """
        self.send_rffReadDouble(key, row, field)
        return self.recv_rffReadDouble()

    def send_rffReadDouble(self, key, row, field):
        self._oprot.writeMessageBegin('rffReadDouble', TMessageType.CALL, self._seqid)
        args = rffReadDouble_args()
        args.key = key
        args.row = row
        args.field = field
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffReadDouble(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffReadDouble_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rffReadDouble failed: unknown result")

    def rffReadLong(self, key, row, field):
        """
        Reads a value out of the input file.

        Parameters:
         - key
         - row
         - field

        """
        self.send_rffReadLong(key, row, field)
        return self.recv_rffReadLong()

    def send_rffReadLong(self, key, row, field):
        self._oprot.writeMessageBegin('rffReadLong', TMessageType.CALL, self._seqid)
        args = rffReadLong_args()
        args.key = key
        args.row = row
        args.field = field
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffReadLong(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffReadLong_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rffReadLong failed: unknown result")

    def rffReadValue(self, key, row, field):
        """
        Reads a value out of the input file.

        Parameters:
         - key
         - row
         - field

        """
        self.send_rffReadValue(key, row, field)
        return self.recv_rffReadValue()

    def send_rffReadValue(self, key, row, field):
        self._oprot.writeMessageBegin('rffReadValue', TMessageType.CALL, self._seqid)
        args = rffReadValue_args()
        args.key = key
        args.row = row
        args.field = field
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffReadValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffReadValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rffReadValue failed: unknown result")

    def rffSetDelimiters(self, key, delimiters):
        """
        Sets the delimiters which should be used for parsing lines into fields.

        Parameters:
         - key
         - delimiters

        """
        self.send_rffSetDelimiters(key, delimiters)
        self.recv_rffSetDelimiters()

    def send_rffSetDelimiters(self, key, delimiters):
        self._oprot.writeMessageBegin('rffSetDelimiters', TMessageType.CALL, self._seqid)
        args = rffSetDelimiters_args()
        args.key = key
        args.delimiters = delimiters
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffSetDelimiters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffSetDelimiters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffSetFileToGenerateOrParse(self, key, fileName):
        """
        Specified the file which will be generated or parsed depending on the mode.

        Parameters:
         - key
         - fileName

        """
        self.send_rffSetFileToGenerateOrParse(key, fileName)
        self.recv_rffSetFileToGenerateOrParse()

    def send_rffSetFileToGenerateOrParse(self, key, fileName):
        self._oprot.writeMessageBegin('rffSetFileToGenerateOrParse', TMessageType.CALL, self._seqid)
        args = rffSetFileToGenerateOrParse_args()
        args.key = key
        args.fileName = fileName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffSetFileToGenerateOrParse(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffSetFileToGenerateOrParse_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffSetTemplateFile(self, key, fileName):
        """
        Specified the template file to read.

        Parameters:
         - key
         - fileName

        """
        self.send_rffSetTemplateFile(key, fileName)
        self.recv_rffSetTemplateFile()

    def send_rffSetTemplateFile(self, key, fileName):
        self._oprot.writeMessageBegin('rffSetTemplateFile', TMessageType.CALL, self._seqid)
        args = rffSetTemplateFile_args()
        args.key = key
        args.fileName = fileName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffSetTemplateFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffSetTemplateFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffTransferArray(self, key, varName, rowstart, rowend, fieldstart, fieldend, resizable, format, numDimensions):
        """
        Transfers the data for a particular array.

        Parameters:
         - key
         - varName
         - rowstart
         - rowend
         - fieldstart
         - fieldend
         - resizable
         - format
         - numDimensions

        """
        self.send_rffTransferArray(key, varName, rowstart, rowend, fieldstart, fieldend, resizable, format, numDimensions)
        self.recv_rffTransferArray()

    def send_rffTransferArray(self, key, varName, rowstart, rowend, fieldstart, fieldend, resizable, format, numDimensions):
        self._oprot.writeMessageBegin('rffTransferArray', TMessageType.CALL, self._seqid)
        args = rffTransferArray_args()
        args.key = key
        args.varName = varName
        args.rowstart = rowstart
        args.rowend = rowend
        args.fieldstart = fieldstart
        args.fieldend = fieldend
        args.resizable = resizable
        args.format = format
        args.numDimensions = numDimensions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffTransferArray(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffTransferArray_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffTransferKeyVar(self, key, varName, searchKey, occurrence, rowOffset, field, fformat):
        """
        Transfers the data for a particular variable.

        Parameters:
         - key
         - varName
         - searchKey
         - occurrence
         - rowOffset
         - field
         - fformat

        """
        self.send_rffTransferKeyVar(key, varName, searchKey, occurrence, rowOffset, field, fformat)
        self.recv_rffTransferKeyVar()

    def send_rffTransferKeyVar(self, key, varName, searchKey, occurrence, rowOffset, field, fformat):
        self._oprot.writeMessageBegin('rffTransferKeyVar', TMessageType.CALL, self._seqid)
        args = rffTransferKeyVar_args()
        args.key = key
        args.varName = varName
        args.searchKey = searchKey
        args.occurrence = occurrence
        args.rowOffset = rowOffset
        args.field = field
        args.fformat = fformat
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffTransferKeyVar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffTransferKeyVar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffTransferVar(self, key, varName, row, field, format):
        """
        Transfers the data for a particular variable.

        Parameters:
         - key
         - varName
         - row
         - field
         - format

        """
        self.send_rffTransferVar(key, varName, row, field, format)
        self.recv_rffTransferVar()

    def send_rffTransferVar(self, key, varName, row, field, format):
        self._oprot.writeMessageBegin('rffTransferVar', TMessageType.CALL, self._seqid)
        args = rffTransferVar_args()
        args.key = key
        args.varName = varName
        args.row = row
        args.field = field
        args.format = format
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffTransferVar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffTransferVar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def rffWriteValue(self, key, row, field, val):
        """
        Writes a token out to the output file.

        Parameters:
         - key
         - row
         - field
         - val

        """
        self.send_rffWriteValue(key, row, field, val)
        self.recv_rffWriteValue()

    def send_rffWriteValue(self, key, row, field, val):
        self._oprot.writeMessageBegin('rffWriteValue', TMessageType.CALL, self._seqid)
        args = rffWriteValue_args()
        args.key = key
        args.row = row
        args.field = field
        args.val = val
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rffWriteValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rffWriteValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareCleanTempDir(self):
        """
        cleans up the temporary run directory if one has been created.

        """
        self.send_runShareCleanTempDir()
        self.recv_runShareCleanTempDir()

    def send_runShareCleanTempDir(self):
        self._oprot.writeMessageBegin('runShareCleanTempDir', TMessageType.CALL, self._seqid)
        args = runShareCleanTempDir_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareCleanTempDir(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareCleanTempDir_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareGetBaseDirectory(self):
        """
        Gets the base dir which was passed in to the constructor.

        """
        self.send_runShareGetBaseDirectory()
        return self.recv_runShareGetBaseDirectory()

    def send_runShareGetBaseDirectory(self):
        self._oprot.writeMessageBegin('runShareGetBaseDirectory', TMessageType.CALL, self._seqid)
        args = runShareGetBaseDirectory_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareGetBaseDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareGetBaseDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runShareGetBaseDirectory failed: unknown result")

    def runShareGetDirectory(self):
        """
        Returns the current directory being used by the runshare system.

        """
        self.send_runShareGetDirectory()
        return self.recv_runShareGetDirectory()

    def send_runShareGetDirectory(self):
        self._oprot.writeMessageBegin('runShareGetDirectory', TMessageType.CALL, self._seqid)
        args = runShareGetDirectory_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareGetDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareGetDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "runShareGetDirectory failed: unknown result")

    def runShareHalt(self):
        """
        halts any running process

        """
        self.send_runShareHalt()
        self.recv_runShareHalt()

    def send_runShareHalt(self):
        self._oprot.writeMessageBegin('runShareHalt', TMessageType.CALL, self._seqid)
        args = runShareHalt_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareHalt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareHalt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareLock(self):
        """
        Causes the run-share mode to be implemented.

        """
        self.send_runShareLock()
        self.recv_runShareLock()

    def send_runShareLock(self):
        self._oprot.writeMessageBegin('runShareLock', TMessageType.CALL, self._seqid)
        args = runShareLock_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareLock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareLock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareRun(self, cmd, ignoreErrors, autoChangeDir, shell):
        """
        Runs a command.

        Parameters:
         - cmd
         - ignoreErrors
         - autoChangeDir
         - shell

        """
        self.send_runShareRun(cmd, ignoreErrors, autoChangeDir, shell)
        self.recv_runShareRun()

    def send_runShareRun(self, cmd, ignoreErrors, autoChangeDir, shell):
        self._oprot.writeMessageBegin('runShareRun', TMessageType.CALL, self._seqid)
        args = runShareRun_args()
        args.cmd = cmd
        args.ignoreErrors = ignoreErrors
        args.autoChangeDir = autoChangeDir
        args.shell = shell
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareRun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareRun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareSetAutoDelete(self, autoDelete):
        """
        Sets the auto-delete mode for runshare mode MODE_SHARE.

        Parameters:
         - autoDelete

        """
        self.send_runShareSetAutoDelete(autoDelete)
        self.recv_runShareSetAutoDelete()

    def send_runShareSetAutoDelete(self, autoDelete):
        self._oprot.writeMessageBegin('runShareSetAutoDelete', TMessageType.CALL, self._seqid)
        args = runShareSetAutoDelete_args()
        args.autoDelete = autoDelete
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareSetAutoDelete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareSetAutoDelete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareSetFilesToCopy(self, files):
        """
        Sets the files which need to be copied when runshare mode is MODE_SHARE.

        Parameters:
         - files

        """
        self.send_runShareSetFilesToCopy(files)
        self.recv_runShareSetFilesToCopy()

    def send_runShareSetFilesToCopy(self, files):
        self._oprot.writeMessageBegin('runShareSetFilesToCopy', TMessageType.CALL, self._seqid)
        args = runShareSetFilesToCopy_args()
        args.files = files
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareSetFilesToCopy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareSetFilesToCopy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareSetMode(self, mode):
        """
        Sets the runshare mode.

        Parameters:
         - mode

        """
        self.send_runShareSetMode(mode)
        self.recv_runShareSetMode()

    def send_runShareSetMode(self, mode):
        self._oprot.writeMessageBegin('runShareSetMode', TMessageType.CALL, self._seqid)
        args = runShareSetMode_args()
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareSetMode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareSetMode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def runShareUnlock(self):
        """
        Unlocks the runshare mechanisms.

        """
        self.send_runShareUnlock()
        self.recv_runShareUnlock()

    def send_runShareUnlock(self):
        self._oprot.writeMessageBegin('runShareUnlock', TMessageType.CALL, self._seqid)
        args = runShareUnlock_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_runShareUnlock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = runShareUnlock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objCallMethod(self, varName, method):
        """
        call an object method
        TODO: This methods needs to return something that can be transformed into the possible return value types.
              e.g. a struct of two strings (type and value), which can be used to construct an object which will be
              a string; a boxed integer or double; a list of strings, integers or doubles.
        TODO: In Python, this method is going to needs some processing of the return value before it can be consumed
              directly by pythonStructs.py, see PHXScriptObject.callMethod line 2527.

        Parameters:
         - varName
         - method

        """
        self.send_objCallMethod(varName, method)
        self.recv_objCallMethod()

    def send_objCallMethod(self, varName, method):
        self._oprot.writeMessageBegin('objCallMethod', TMessageType.CALL, self._seqid)
        args = objCallMethod_args()
        args.varName = varName
        args.method = method
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objCallMethod(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objCallMethod_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objDeleteAllMembers(self, varName):
        """
        delete all members

        Parameters:
         - varName

        """
        self.send_objDeleteAllMembers(varName)
        self.recv_objDeleteAllMembers()

    def send_objDeleteAllMembers(self, varName):
        self._oprot.writeMessageBegin('objDeleteAllMembers', TMessageType.CALL, self._seqid)
        args = objDeleteAllMembers_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objDeleteAllMembers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objDeleteAllMembers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objDeleteMember(self, varName, mIndex):
        """
        delete a member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objDeleteMember(varName, mIndex)
        self.recv_objDeleteMember()

    def send_objDeleteMember(self, varName, mIndex):
        self._oprot.writeMessageBegin('objDeleteMember', TMessageType.CALL, self._seqid)
        args = objDeleteMember_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objDeleteMember(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objDeleteMember_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objFromFile(self, varName, mIndex, fileName):
        """
        set content of a file member from a file

        Parameters:
         - varName
         - mIndex
         - fileName

        """
        self.send_objFromFile(varName, mIndex, fileName)
        self.recv_objFromFile()

    def send_objFromFile(self, varName, mIndex, fileName):
        self._oprot.writeMessageBegin('objFromFile', TMessageType.CALL, self._seqid)
        args = objFromFile_args()
        args.varName = varName
        args.mIndex = mIndex
        args.fileName = fileName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objFromFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objFromFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objFromString(self, varName, strVal):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - strVal

        """
        self.send_objFromString(varName, strVal)
        self.recv_objFromString()

    def send_objFromString(self, varName, strVal):
        self._oprot.writeMessageBegin('objFromString', TMessageType.CALL, self._seqid)
        args = objFromString_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objFromXML(self, varName, strVal):
        """
        set the content of the object from the XML string

        Parameters:
         - varName
         - strVal

        """
        self.send_objFromXML(varName, strVal)
        self.recv_objFromXML()

    def send_objFromXML(self, varName, strVal):
        self._oprot.writeMessageBegin('objFromXML', TMessageType.CALL, self._seqid)
        args = objFromXML_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objFromXML(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objFromXML_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objGetBooleanArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of a boolean array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        self.send_objGetBooleanArrayMemberValue(varName, mIndex, index)
        return self.recv_objGetBooleanArrayMemberValue()

    def send_objGetBooleanArrayMemberValue(self, varName, mIndex, index):
        self._oprot.writeMessageBegin('objGetBooleanArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objGetBooleanArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetBooleanArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetBooleanArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetBooleanArrayMemberValue failed: unknown result")

    def objGetBooleanMemberValue(self, varName, mIndex):
        """
        return value of a boolean member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetBooleanMemberValue(varName, mIndex)
        return self.recv_objGetBooleanMemberValue()

    def send_objGetBooleanMemberValue(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetBooleanMemberValue', TMessageType.CALL, self._seqid)
        args = objGetBooleanMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetBooleanMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetBooleanMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetBooleanMemberValue failed: unknown result")

    def objGetClassURL(self, varName):
        """
        return the class URL

        Parameters:
         - varName

        """
        self.send_objGetClassURL(varName)
        return self.recv_objGetClassURL()

    def send_objGetClassURL(self, varName):
        self._oprot.writeMessageBegin('objGetClassURL', TMessageType.CALL, self._seqid)
        args = objGetClassURL_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetClassURL(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetClassURL_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetClassURL failed: unknown result")

    def objGetDoubleArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of a double array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        self.send_objGetDoubleArrayMemberValue(varName, mIndex, index)
        return self.recv_objGetDoubleArrayMemberValue()

    def send_objGetDoubleArrayMemberValue(self, varName, mIndex, index):
        self._oprot.writeMessageBegin('objGetDoubleArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objGetDoubleArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetDoubleArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetDoubleArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetDoubleArrayMemberValue failed: unknown result")

    def objGetDoubleMemberValue(self, varName, mIndex):
        """
        return value of a double member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetDoubleMemberValue(varName, mIndex)
        return self.recv_objGetDoubleMemberValue()

    def send_objGetDoubleMemberValue(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetDoubleMemberValue', TMessageType.CALL, self._seqid)
        args = objGetDoubleMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetDoubleMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetDoubleMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetDoubleMemberValue failed: unknown result")

    def objGetFileName(self, varName, mIndex):
        """
        return file name of a file member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetFileName(varName, mIndex)
        return self.recv_objGetFileName()

    def send_objGetFileName(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetFileName', TMessageType.CALL, self._seqid)
        args = objGetFileName_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetFileName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetFileName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetFileName failed: unknown result")

    def objGetIntArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of an int array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        self.send_objGetIntArrayMemberValue(varName, mIndex, index)
        return self.recv_objGetIntArrayMemberValue()

    def send_objGetIntArrayMemberValue(self, varName, mIndex, index):
        self._oprot.writeMessageBegin('objGetIntArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objGetIntArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetIntArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetIntArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetIntArrayMemberValue failed: unknown result")

    def objGetIntMemberValue(self, varName, mIndex):
        """
        return value of an int member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetIntMemberValue(varName, mIndex)
        return self.recv_objGetIntMemberValue()

    def send_objGetIntMemberValue(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetIntMemberValue', TMessageType.CALL, self._seqid)
        args = objGetIntMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetIntMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetIntMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetIntMemberValue failed: unknown result")

    def objGetIsBinary(self, varName, mIndex):
        """
        return True if file member contains a binary file

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetIsBinary(varName, mIndex)
        return self.recv_objGetIsBinary()

    def send_objGetIsBinary(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetIsBinary', TMessageType.CALL, self._seqid)
        args = objGetIsBinary_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetIsBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetIsBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetIsBinary failed: unknown result")

    def objGetMemberDescription(self, varName, mIndex):
        """
        return description of the member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberDescription(varName, mIndex)
        return self.recv_objGetMemberDescription()

    def send_objGetMemberDescription(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberDescription', TMessageType.CALL, self._seqid)
        args = objGetMemberDescription_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberDescription failed: unknown result")

    def objGetMemberDimensions(self, varName, mIndex):
        """
        get dimensions of an array member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberDimensions(varName, mIndex)
        return self.recv_objGetMemberDimensions()

    def send_objGetMemberDimensions(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberDimensions', TMessageType.CALL, self._seqid)
        args = objGetMemberDimensions_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberDimensions failed: unknown result")

    def objGetMemberEnumAliases(self, varName, mIndex):
        """
        return enum aliases of the member as a comma separated string

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberEnumAliases(varName, mIndex)
        return self.recv_objGetMemberEnumAliases()

    def send_objGetMemberEnumAliases(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberEnumAliases', TMessageType.CALL, self._seqid)
        args = objGetMemberEnumAliases_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberEnumAliases failed: unknown result")

    def objGetMemberEnumValues(self, varName, mIndex):
        """
        return enum values of the member as a comma separated string

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberEnumValues(varName, mIndex)
        return self.recv_objGetMemberEnumValues()

    def send_objGetMemberEnumValues(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberEnumValues', TMessageType.CALL, self._seqid)
        args = objGetMemberEnumValues_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberEnumValues failed: unknown result")

    def objGetMemberLength(self, varName, mIndex, dim):
        """
        return length of an array member

        Parameters:
         - varName
         - mIndex
         - dim

        """
        self.send_objGetMemberLength(varName, mIndex, dim)
        return self.recv_objGetMemberLength()

    def send_objGetMemberLength(self, varName, mIndex, dim):
        self._oprot.writeMessageBegin('objGetMemberLength', TMessageType.CALL, self._seqid)
        args = objGetMemberLength_args()
        args.varName = varName
        args.mIndex = mIndex
        args.dim = dim
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberLength failed: unknown result")

    def objGetMemberLowerBound(self, varName, mIndex):
        """
        return lowerBound of the member as a string

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberLowerBound(varName, mIndex)
        return self.recv_objGetMemberLowerBound()

    def send_objGetMemberLowerBound(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberLowerBound', TMessageType.CALL, self._seqid)
        args = objGetMemberLowerBound_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberLowerBound failed: unknown result")

    def objGetMemberNumDimensions(self, varName, mIndex):
        """
        get number of dimensions of an array member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberNumDimensions(varName, mIndex)
        return self.recv_objGetMemberNumDimensions()

    def send_objGetMemberNumDimensions(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberNumDimensions', TMessageType.CALL, self._seqid)
        args = objGetMemberNumDimensions_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberNumDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberNumDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberNumDimensions failed: unknown result")

    def objGetMemberProperty(self, varName, mIndex, propertyName):
        """
        return a meta data property of the member

        Parameters:
         - varName
         - mIndex
         - propertyName

        """
        self.send_objGetMemberProperty(varName, mIndex, propertyName)
        return self.recv_objGetMemberProperty()

    def send_objGetMemberProperty(self, varName, mIndex, propertyName):
        self._oprot.writeMessageBegin('objGetMemberProperty', TMessageType.CALL, self._seqid)
        args = objGetMemberProperty_args()
        args.varName = varName
        args.mIndex = mIndex
        args.propertyName = propertyName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberProperty failed: unknown result")

    def objGetMemberType(self, varName, mIndex):
        """
        get type of a member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberType(varName, mIndex)
        return self.recv_objGetMemberType()

    def send_objGetMemberType(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberType', TMessageType.CALL, self._seqid)
        args = objGetMemberType_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberType failed: unknown result")

    def objGetMemberUnits(self, varName, mIndex):
        """
        return units of the member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberUnits(varName, mIndex)
        return self.recv_objGetMemberUnits()

    def send_objGetMemberUnits(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberUnits', TMessageType.CALL, self._seqid)
        args = objGetMemberUnits_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberUnits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberUnits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberUnits failed: unknown result")

    def objGetMemberUpperBound(self, varName, mIndex):
        """
        return upperBound of the member as a string

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberUpperBound(varName, mIndex)
        return self.recv_objGetMemberUpperBound()

    def send_objGetMemberUpperBound(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberUpperBound', TMessageType.CALL, self._seqid)
        args = objGetMemberUpperBound_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberUpperBound failed: unknown result")

    def objGetMemberValueAsString(self, varName, mIndex):
        """
        return member value as a string

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetMemberValueAsString(varName, mIndex)
        return self.recv_objGetMemberValueAsString()

    def send_objGetMemberValueAsString(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetMemberValueAsString', TMessageType.CALL, self._seqid)
        args = objGetMemberValueAsString_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetMemberValueAsString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetMemberValueAsString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetMemberValueAsString failed: unknown result")

    def objGetStringArrayMemberValue(self, varName, mIndex, index):
        """
        return value of an element of a string array member

        Parameters:
         - varName
         - mIndex
         - index

        """
        self.send_objGetStringArrayMemberValue(varName, mIndex, index)
        return self.recv_objGetStringArrayMemberValue()

    def send_objGetStringArrayMemberValue(self, varName, mIndex, index):
        self._oprot.writeMessageBegin('objGetStringArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objGetStringArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetStringArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetStringArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetStringArrayMemberValue failed: unknown result")

    def objGetStringMemberValue(self, varName, mIndex):
        """
        return value of a string member

        Parameters:
         - varName
         - mIndex

        """
        self.send_objGetStringMemberValue(varName, mIndex)
        return self.recv_objGetStringMemberValue()

    def send_objGetStringMemberValue(self, varName, mIndex):
        self._oprot.writeMessageBegin('objGetStringMemberValue', TMessageType.CALL, self._seqid)
        args = objGetStringMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objGetStringMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objGetStringMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objGetStringMemberValue failed: unknown result")

    def objHasMember(self, varName, mIndex):
        """
        return true if the member exists

        Parameters:
         - varName
         - mIndex

        """
        self.send_objHasMember(varName, mIndex)
        return self.recv_objHasMember()

    def send_objHasMember(self, varName, mIndex):
        self._oprot.writeMessageBegin('objHasMember', TMessageType.CALL, self._seqid)
        args = objHasMember_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objHasMember(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objHasMember_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objHasMember failed: unknown result")

    def objHasMemberLowerBound(self, varName, mIndex):
        """
        return true if the member has the lowerBound defined

        Parameters:
         - varName
         - mIndex

        """
        self.send_objHasMemberLowerBound(varName, mIndex)
        return self.recv_objHasMemberLowerBound()

    def send_objHasMemberLowerBound(self, varName, mIndex):
        self._oprot.writeMessageBegin('objHasMemberLowerBound', TMessageType.CALL, self._seqid)
        args = objHasMemberLowerBound_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objHasMemberLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objHasMemberLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objHasMemberLowerBound failed: unknown result")

    def objHasMemberUpperBound(self, varName, mIndex):
        """
        return true if the member has the upperBound defined

        Parameters:
         - varName
         - mIndex

        """
        self.send_objHasMemberUpperBound(varName, mIndex)
        return self.recv_objHasMemberUpperBound()

    def send_objHasMemberUpperBound(self, varName, mIndex):
        self._oprot.writeMessageBegin('objHasMemberUpperBound', TMessageType.CALL, self._seqid)
        args = objHasMemberUpperBound_args()
        args.varName = varName
        args.mIndex = mIndex
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objHasMemberUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objHasMemberUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objHasMemberUpperBound failed: unknown result")

    def objIsNonStrictType(self, varName):
        """
        return true if the object is a non-strict type

        Parameters:
         - varName

        """
        self.send_objIsNonStrictType(varName)
        return self.recv_objIsNonStrictType()

    def send_objIsNonStrictType(self, varName):
        self._oprot.writeMessageBegin('objIsNonStrictType', TMessageType.CALL, self._seqid)
        args = objIsNonStrictType_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objIsNonStrictType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objIsNonStrictType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objIsNonStrictType failed: unknown result")

    def objSetBaseName(self, varName, mIndex, value):
        """
        set base name of a file member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetBaseName(varName, mIndex, value)
        self.recv_objSetBaseName()

    def send_objSetBaseName(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetBaseName', TMessageType.CALL, self._seqid)
        args = objSetBaseName_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetBaseName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetBaseName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetBooleanArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a boolean array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        self.send_objSetBooleanArrayMemberValue(varName, mIndex, index, value)
        self.recv_objSetBooleanArrayMemberValue()

    def send_objSetBooleanArrayMemberValue(self, varName, mIndex, index, value):
        self._oprot.writeMessageBegin('objSetBooleanArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objSetBooleanArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetBooleanArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetBooleanArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetBooleanMemberValue(self, varName, mIndex, boolVal):
        """
        set value of a boolean member

        Parameters:
         - varName
         - mIndex
         - boolVal

        """
        self.send_objSetBooleanMemberValue(varName, mIndex, boolVal)
        self.recv_objSetBooleanMemberValue()

    def send_objSetBooleanMemberValue(self, varName, mIndex, boolVal):
        self._oprot.writeMessageBegin('objSetBooleanMemberValue', TMessageType.CALL, self._seqid)
        args = objSetBooleanMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetBooleanMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetBooleanMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetDoubleArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a double array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        self.send_objSetDoubleArrayMemberValue(varName, mIndex, index, value)
        self.recv_objSetDoubleArrayMemberValue()

    def send_objSetDoubleArrayMemberValue(self, varName, mIndex, index, value):
        self._oprot.writeMessageBegin('objSetDoubleArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objSetDoubleArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetDoubleArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetDoubleArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetDoubleMemberValue(self, varName, mIndex, value):
        """
        set value of a double member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetDoubleMemberValue(varName, mIndex, value)
        self.recv_objSetDoubleMemberValue()

    def send_objSetDoubleMemberValue(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetDoubleMemberValue', TMessageType.CALL, self._seqid)
        args = objSetDoubleMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetDoubleMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetDoubleMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetFileExtension(self, varName, mIndex, value):
        """
        set file extension of a file member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetFileExtension(varName, mIndex, value)
        self.recv_objSetFileExtension()

    def send_objSetFileExtension(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetFileExtension', TMessageType.CALL, self._seqid)
        args = objSetFileExtension_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetFileExtension(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetFileExtension_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetFileName(self, varName, mIndex, value):
        """
        set file name of a file member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetFileName(varName, mIndex, value)
        self.recv_objSetFileName()

    def send_objSetFileName(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetFileName', TMessageType.CALL, self._seqid)
        args = objSetFileName_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetFileName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetFileName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetIntArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a int array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        self.send_objSetIntArrayMemberValue(varName, mIndex, index, value)
        self.recv_objSetIntArrayMemberValue()

    def send_objSetIntArrayMemberValue(self, varName, mIndex, index, value):
        self._oprot.writeMessageBegin('objSetIntArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objSetIntArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetIntArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetIntArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetIntMemberValue(self, varName, mIndex, value):
        """
        set value of a int member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetIntMemberValue(varName, mIndex, value)
        self.recv_objSetIntMemberValue()

    def send_objSetIntMemberValue(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetIntMemberValue', TMessageType.CALL, self._seqid)
        args = objSetIntMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetIntMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetIntMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetIsBinary(self, varName, mIndex, flag):
        """
        set binary flag for the file member

        Parameters:
         - varName
         - mIndex
         - flag

        """
        self.send_objSetIsBinary(varName, mIndex, flag)
        self.recv_objSetIsBinary()

    def send_objSetIsBinary(self, varName, mIndex, flag):
        self._oprot.writeMessageBegin('objSetIsBinary', TMessageType.CALL, self._seqid)
        args = objSetIsBinary_args()
        args.varName = varName
        args.mIndex = mIndex
        args.flag = flag
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetIsBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetIsBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMember(self, varName, mIndex, value, type):
        """
        set member. Create a member if not exists.

        Parameters:
         - varName
         - mIndex
         - value
         - type

        """
        self.send_objSetMember(varName, mIndex, value, type)
        self.recv_objSetMember()

    def send_objSetMember(self, varName, mIndex, value, type):
        self._oprot.writeMessageBegin('objSetMember', TMessageType.CALL, self._seqid)
        args = objSetMember_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMember(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMember_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberDescription(self, varName, mIndex, value):
        """
        set description of the member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberDescription(varName, mIndex, value)
        self.recv_objSetMemberDescription()

    def send_objSetMemberDescription(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberDescription', TMessageType.CALL, self._seqid)
        args = objSetMemberDescription_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberDimensions(self, varName, mIndex, strVal):
        """
        set dimensions of an array member

        Parameters:
         - varName
         - mIndex
         - strVal

        """
        self.send_objSetMemberDimensions(varName, mIndex, strVal)
        self.recv_objSetMemberDimensions()

    def send_objSetMemberDimensions(self, varName, mIndex, strVal):
        self._oprot.writeMessageBegin('objSetMemberDimensions', TMessageType.CALL, self._seqid)
        args = objSetMemberDimensions_args()
        args.varName = varName
        args.mIndex = mIndex
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberEnumAliases(self, varName, mIndex, value):
        """
        set enum aliases of the member from a comma separated string

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberEnumAliases(varName, mIndex, value)
        self.recv_objSetMemberEnumAliases()

    def send_objSetMemberEnumAliases(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberEnumAliases', TMessageType.CALL, self._seqid)
        args = objSetMemberEnumAliases_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberEnumValues(self, varName, mIndex, value):
        """
        set enum values of the member from a comma separated string

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberEnumValues(varName, mIndex, value)
        self.recv_objSetMemberEnumValues()

    def send_objSetMemberEnumValues(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberEnumValues', TMessageType.CALL, self._seqid)
        args = objSetMemberEnumValues_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberLength(self, varName, mIndex, length, dim):
        """
        set length of an array member

        Parameters:
         - varName
         - mIndex
         - length
         - dim

        """
        self.send_objSetMemberLength(varName, mIndex, length, dim)
        self.recv_objSetMemberLength()

    def send_objSetMemberLength(self, varName, mIndex, length, dim):
        self._oprot.writeMessageBegin('objSetMemberLength', TMessageType.CALL, self._seqid)
        args = objSetMemberLength_args()
        args.varName = varName
        args.mIndex = mIndex
        args.length = length
        args.dim = dim
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberLowerBound(self, varName, mIndex, value):
        """
        set lowerBound of the member from string

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberLowerBound(varName, mIndex, value)
        self.recv_objSetMemberLowerBound()

    def send_objSetMemberLowerBound(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberLowerBound', TMessageType.CALL, self._seqid)
        args = objSetMemberLowerBound_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberLowerBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberLowerBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberProperty(self, varName, mIndex, propertyName, propertyValue):
        """
        set a meta data property of the member

        Parameters:
         - varName
         - mIndex
         - propertyName
         - propertyValue

        """
        self.send_objSetMemberProperty(varName, mIndex, propertyName, propertyValue)
        self.recv_objSetMemberProperty()

    def send_objSetMemberProperty(self, varName, mIndex, propertyName, propertyValue):
        self._oprot.writeMessageBegin('objSetMemberProperty', TMessageType.CALL, self._seqid)
        args = objSetMemberProperty_args()
        args.varName = varName
        args.mIndex = mIndex
        args.propertyName = propertyName
        args.propertyValue = propertyValue
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberUnits(self, varName, mIndex, value):
        """
        set units of the member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberUnits(varName, mIndex, value)
        self.recv_objSetMemberUnits()

    def send_objSetMemberUnits(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberUnits', TMessageType.CALL, self._seqid)
        args = objSetMemberUnits_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberUnits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberUnits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberUpperBound(self, varName, mIndex, value):
        """
        set upperBound of the member from string

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberUpperBound(varName, mIndex, value)
        self.recv_objSetMemberUpperBound()

    def send_objSetMemberUpperBound(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberUpperBound', TMessageType.CALL, self._seqid)
        args = objSetMemberUpperBound_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberUpperBound(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberUpperBound_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetMemberValueFromString(self, varName, mIndex, value):
        """
        set value of a member from a string value

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetMemberValueFromString(varName, mIndex, value)
        self.recv_objSetMemberValueFromString()

    def send_objSetMemberValueFromString(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetMemberValueFromString', TMessageType.CALL, self._seqid)
        args = objSetMemberValueFromString_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetMemberValueFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetMemberValueFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetStringArrayMemberValue(self, varName, mIndex, index, value):
        """
        set value of an element of a string array member

        Parameters:
         - varName
         - mIndex
         - index
         - value

        """
        self.send_objSetStringArrayMemberValue(varName, mIndex, index, value)
        self.recv_objSetStringArrayMemberValue()

    def send_objSetStringArrayMemberValue(self, varName, mIndex, index, value):
        self._oprot.writeMessageBegin('objSetStringArrayMemberValue', TMessageType.CALL, self._seqid)
        args = objSetStringArrayMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetStringArrayMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetStringArrayMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objSetStringMemberValue(self, varName, mIndex, value):
        """
        set value of a string member

        Parameters:
         - varName
         - mIndex
         - value

        """
        self.send_objSetStringMemberValue(varName, mIndex, value)
        self.recv_objSetStringMemberValue()

    def send_objSetStringMemberValue(self, varName, mIndex, value):
        self._oprot.writeMessageBegin('objSetStringMemberValue', TMessageType.CALL, self._seqid)
        args = objSetStringMemberValue_args()
        args.varName = varName
        args.mIndex = mIndex
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objSetStringMemberValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objSetStringMemberValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objToFile(self, varName, mIndex, fileName):
        """
        write content of a file member to a file

        Parameters:
         - varName
         - mIndex
         - fileName

        """
        self.send_objToFile(varName, mIndex, fileName)
        self.recv_objToFile()

    def send_objToFile(self, varName, mIndex, fileName):
        self._oprot.writeMessageBegin('objToFile', TMessageType.CALL, self._seqid)
        args = objToFile_args()
        args.varName = varName
        args.mIndex = mIndex
        args.fileName = fileName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objToFile(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objToFile_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def objToString(self, varName):
        """
        converts the variable to a string

        Parameters:
         - varName

        """
        self.send_objToString(varName)
        return self.recv_objToString()

    def send_objToString(self, varName):
        self._oprot.writeMessageBegin('objToString', TMessageType.CALL, self._seqid)
        args = objToString_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objToString failed: unknown result")

    def objToXML(self, varName):
        """
        return XML representation of the object

        Parameters:
         - varName

        """
        self.send_objToXML(varName)
        return self.recv_objToXML()

    def send_objToXML(self, varName):
        self._oprot.writeMessageBegin('objToXML', TMessageType.CALL, self._seqid)
        args = objToXML_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_objToXML(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = objToXML_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "objToXML failed: unknown result")

    def wrapperAddMethod(self, methodName, fullName, downloadInputs):
        """
        register a custom method with the component

        Parameters:
         - methodName
         - fullName
         - downloadInputs

        """
        self.send_wrapperAddMethod(methodName, fullName, downloadInputs)
        self.recv_wrapperAddMethod()

    def send_wrapperAddMethod(self, methodName, fullName, downloadInputs):
        self._oprot.writeMessageBegin('wrapperAddMethod', TMessageType.CALL, self._seqid)
        args = wrapperAddMethod_args()
        args.methodName = methodName
        args.fullName = fullName
        args.downloadInputs = downloadInputs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperAddMethod(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperAddMethod_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def wrapperAddVariable(self, varName, varType, isInput):
        """
        add a new variable to the component

        Parameters:
         - varName
         - varType
         - isInput

        """
        self.send_wrapperAddVariable(varName, varType, isInput)
        self.recv_wrapperAddVariable()

    def send_wrapperAddVariable(self, varName, varType, isInput):
        self._oprot.writeMessageBegin('wrapperAddVariable', TMessageType.CALL, self._seqid)
        args = wrapperAddVariable_args()
        args.varName = varName
        args.varType = varType
        args.isInput = isInput
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperAddVariable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperAddVariable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def wrapperGetDictKey(self, index):
        """
        gets the dictionary key of the given index

        Parameters:
         - index

        """
        self.send_wrapperGetDictKey(index)
        return self.recv_wrapperGetDictKey()

    def send_wrapperGetDictKey(self, index):
        self._oprot.writeMessageBegin('wrapperGetDictKey', TMessageType.CALL, self._seqid)
        args = wrapperGetDictKey_args()
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperGetDictKey(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperGetDictKey_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wrapperGetDictKey failed: unknown result")

    def wrapperGetDictNumEntries(self):
        """
        gets the number of items in the connection's dictionary

        """
        self.send_wrapperGetDictNumEntries()
        return self.recv_wrapperGetDictNumEntries()

    def send_wrapperGetDictNumEntries(self):
        self._oprot.writeMessageBegin('wrapperGetDictNumEntries', TMessageType.CALL, self._seqid)
        args = wrapperGetDictNumEntries_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperGetDictNumEntries(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperGetDictNumEntries_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wrapperGetDictNumEntries failed: unknown result")

    def wrapperGetDictValue(self, index):
        """
        gets the dictionary value of the given index

        Parameters:
         - index

        """
        self.send_wrapperGetDictValue(index)
        return self.recv_wrapperGetDictValue()

    def send_wrapperGetDictValue(self, index):
        self._oprot.writeMessageBegin('wrapperGetDictValue', TMessageType.CALL, self._seqid)
        args = wrapperGetDictValue_args()
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperGetDictValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperGetDictValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wrapperGetDictValue failed: unknown result")

    def wrapperGetDirectory(self):
        """
        Returns the directory where this component was loaded from

        """
        self.send_wrapperGetDirectory()
        return self.recv_wrapperGetDirectory()

    def send_wrapperGetDirectory(self):
        self._oprot.writeMessageBegin('wrapperGetDirectory', TMessageType.CALL, self._seqid)
        args = wrapperGetDirectory_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperGetDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperGetDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wrapperGetDirectory failed: unknown result")

    def wrapperGetRunDirectory(self):
        """
        Returns the current run directory, which is the same as getDirectory() unless run sharing is being used.

        """
        self.send_wrapperGetRunDirectory()
        return self.recv_wrapperGetRunDirectory()

    def send_wrapperGetRunDirectory(self):
        self._oprot.writeMessageBegin('wrapperGetRunDirectory', TMessageType.CALL, self._seqid)
        args = wrapperGetRunDirectory_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperGetRunDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperGetRunDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wrapperGetRunDirectory failed: unknown result")

    def wrapperGetVarType(self, varName):
        """
        gets the type of the specified variable

        Parameters:
         - varName

        """
        self.send_wrapperGetVarType(varName)
        return self.recv_wrapperGetVarType()

    def send_wrapperGetVarType(self, varName):
        self._oprot.writeMessageBegin('wrapperGetVarType', TMessageType.CALL, self._seqid)
        args = wrapperGetVarType_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperGetVarType(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperGetVarType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wrapperGetVarType failed: unknown result")

    def wrapperRemoveVariable(self, varName):
        """
        Dynamically removes a variable from this component

        Parameters:
         - varName

        """
        self.send_wrapperRemoveVariable(varName)
        self.recv_wrapperRemoveVariable()

    def send_wrapperRemoveVariable(self, varName):
        self._oprot.writeMessageBegin('wrapperRemoveVariable', TMessageType.CALL, self._seqid)
        args = wrapperRemoveVariable_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperRemoveVariable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperRemoveVariable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def wrapperSleep(self, milliSeconds):
        """
        sleeps for a period of time

        Parameters:
         - milliSeconds

        """
        self.send_wrapperSleep(milliSeconds)
        self.recv_wrapperSleep()

    def send_wrapperSleep(self, milliSeconds):
        self._oprot.writeMessageBegin('wrapperSleep', TMessageType.CALL, self._seqid)
        args = wrapperSleep_args()
        args.milliSeconds = milliSeconds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wrapperSleep(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wrapperSleep_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def arrayFromString(self, varName, strVal):
        """
        reads in the entire array in string form.

        Parameters:
         - varName
         - strVal

        """
        self.send_arrayFromString(varName, strVal)
        self.recv_arrayFromString()

    def send_arrayFromString(self, varName, strVal):
        self._oprot.writeMessageBegin('arrayFromString', TMessageType.CALL, self._seqid)
        args = arrayFromString_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def arrayGetDimensions(self, varName):
        """
        Gets the dimensions of the array in string form

        Parameters:
         - varName

        """
        self.send_arrayGetDimensions(varName)
        return self.recv_arrayGetDimensions()

    def send_arrayGetDimensions(self, varName):
        self._oprot.writeMessageBegin('arrayGetDimensions', TMessageType.CALL, self._seqid)
        args = arrayGetDimensions_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayGetDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayGetDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "arrayGetDimensions failed: unknown result")

    def arrayGetLength(self, varName, dim):
        """
        Gets the length of a dimension of the array

        Parameters:
         - varName
         - dim

        """
        self.send_arrayGetLength(varName, dim)
        return self.recv_arrayGetLength()

    def send_arrayGetLength(self, varName, dim):
        self._oprot.writeMessageBegin('arrayGetLength', TMessageType.CALL, self._seqid)
        args = arrayGetLength_args()
        args.varName = varName
        args.dim = dim
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayGetLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayGetLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "arrayGetLength failed: unknown result")

    def arrayGetLockResize(self, varName):
        """
        Return whether the array be resized

        Parameters:
         - varName

        """
        self.send_arrayGetLockResize(varName)
        return self.recv_arrayGetLockResize()

    def send_arrayGetLockResize(self, varName):
        self._oprot.writeMessageBegin('arrayGetLockResize', TMessageType.CALL, self._seqid)
        args = arrayGetLockResize_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayGetLockResize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayGetLockResize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "arrayGetLockResize failed: unknown result")

    def arrayGetNumDimensions(self, varName):
        """
        Gets the number of dimensions the array has

        Parameters:
         - varName

        """
        self.send_arrayGetNumDimensions(varName)
        return self.recv_arrayGetNumDimensions()

    def send_arrayGetNumDimensions(self, varName):
        self._oprot.writeMessageBegin('arrayGetNumDimensions', TMessageType.CALL, self._seqid)
        args = arrayGetNumDimensions_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayGetNumDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayGetNumDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "arrayGetNumDimensions failed: unknown result")

    def arrayLockDimensions(self, varName):
        """
        Tells this array that the number of dimensions cannot be changed from what they are right now.

        Parameters:
         - varName

        """
        self.send_arrayLockDimensions(varName)
        self.recv_arrayLockDimensions()

    def send_arrayLockDimensions(self, varName):
        self._oprot.writeMessageBegin('arrayLockDimensions', TMessageType.CALL, self._seqid)
        args = arrayLockDimensions_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayLockDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayLockDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def arraySetDimensions(self, varName, strVal):
        """
        Sets the dimensions of the array from a string

        Parameters:
         - varName
         - strVal

        """
        self.send_arraySetDimensions(varName, strVal)
        self.recv_arraySetDimensions()

    def send_arraySetDimensions(self, varName, strVal):
        self._oprot.writeMessageBegin('arraySetDimensions', TMessageType.CALL, self._seqid)
        args = arraySetDimensions_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arraySetDimensions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arraySetDimensions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def arraySetLength(self, varName, length, dim):
        """
        Sets the length of a dimensions of the array.

        Parameters:
         - varName
         - length
         - dim

        """
        self.send_arraySetLength(varName, length, dim)
        self.recv_arraySetLength()

    def send_arraySetLength(self, varName, length, dim):
        self._oprot.writeMessageBegin('arraySetLength', TMessageType.CALL, self._seqid)
        args = arraySetLength_args()
        args.varName = varName
        args.length = length
        args.dim = dim
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arraySetLength(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arraySetLength_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def arraySetLockResize(self, varName, boolVal):
        """
        Tells this array that it cannot be resized.

        Parameters:
         - varName
         - boolVal

        """
        self.send_arraySetLockResize(varName, boolVal)
        self.recv_arraySetLockResize()

    def send_arraySetLockResize(self, varName, boolVal):
        self._oprot.writeMessageBegin('arraySetLockResize', TMessageType.CALL, self._seqid)
        args = arraySetLockResize_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arraySetLockResize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arraySetLockResize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def arrayToString(self, varName):
        """
        Returns the string form of this array.

        Parameters:
         - varName

        """
        self.send_arrayToString(varName)
        return self.recv_arrayToString()

    def send_arrayToString(self, varName):
        self._oprot.writeMessageBegin('arrayToString', TMessageType.CALL, self._seqid)
        args = arrayToString_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_arrayToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = arrayToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "arrayToString failed: unknown result")

    def simpleGetDescription(self, varName):
        """
        get the description

        Parameters:
         - varName

        """
        self.send_simpleGetDescription(varName)
        return self.recv_simpleGetDescription()

    def send_simpleGetDescription(self, varName):
        self._oprot.writeMessageBegin('simpleGetDescription', TMessageType.CALL, self._seqid)
        args = simpleGetDescription_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simpleGetDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simpleGetDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simpleGetDescription failed: unknown result")

    def simpleGetHasChanged(self, varName):
        """
        get the hasChanged flag

        Parameters:
         - varName

        """
        self.send_simpleGetHasChanged(varName)
        return self.recv_simpleGetHasChanged()

    def send_simpleGetHasChanged(self, varName):
        self._oprot.writeMessageBegin('simpleGetHasChanged', TMessageType.CALL, self._seqid)
        args = simpleGetHasChanged_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simpleGetHasChanged(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simpleGetHasChanged_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simpleGetHasChanged failed: unknown result")

    def simpleGetUnits(self, varName):
        """
        get the units

        Parameters:
         - varName

        """
        self.send_simpleGetUnits(varName)
        return self.recv_simpleGetUnits()

    def send_simpleGetUnits(self, varName):
        self._oprot.writeMessageBegin('simpleGetUnits', TMessageType.CALL, self._seqid)
        args = simpleGetUnits_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simpleGetUnits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simpleGetUnits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simpleGetUnits failed: unknown result")

    def simpleSetDescription(self, varName, strVal):
        """
        set the description

        Parameters:
         - varName
         - strVal

        """
        self.send_simpleSetDescription(varName, strVal)
        self.recv_simpleSetDescription()

    def send_simpleSetDescription(self, varName, strVal):
        self._oprot.writeMessageBegin('simpleSetDescription', TMessageType.CALL, self._seqid)
        args = simpleSetDescription_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simpleSetDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simpleSetDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def simpleSetHasChanged(self, varName, boolVal):
        """
        set the hasChanged flag

        Parameters:
         - varName
         - boolVal

        """
        self.send_simpleSetHasChanged(varName, boolVal)
        self.recv_simpleSetHasChanged()

    def send_simpleSetHasChanged(self, varName, boolVal):
        self._oprot.writeMessageBegin('simpleSetHasChanged', TMessageType.CALL, self._seqid)
        args = simpleSetHasChanged_args()
        args.varName = varName
        args.boolVal = boolVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simpleSetHasChanged(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simpleSetHasChanged_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def simpleSetUnits(self, varName, strVal):
        """
        set the units

        Parameters:
         - varName
         - strVal

        """
        self.send_simpleSetUnits(varName, strVal)
        self.recv_simpleSetUnits()

    def send_simpleSetUnits(self, varName, strVal):
        self._oprot.writeMessageBegin('simpleSetUnits', TMessageType.CALL, self._seqid)
        args = simpleSetUnits_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simpleSetUnits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simpleSetUnits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strGetEnumAliases(self, varName):
        """
        gets the enumerated aliases as a comma-separated list

        Parameters:
         - varName

        """
        self.send_strGetEnumAliases(varName)
        return self.recv_strGetEnumAliases()

    def send_strGetEnumAliases(self, varName):
        self._oprot.writeMessageBegin('strGetEnumAliases', TMessageType.CALL, self._seqid)
        args = strGetEnumAliases_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strGetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strGetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strGetEnumAliases failed: unknown result")

    def strGetEnumValues(self, varName):
        """
        gets the enumerated values as a comma-separated list

        Parameters:
         - varName

        """
        self.send_strGetEnumValues(varName)
        return self.recv_strGetEnumValues()

    def send_strGetEnumValues(self, varName):
        self._oprot.writeMessageBegin('strGetEnumValues', TMessageType.CALL, self._seqid)
        args = strGetEnumValues_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strGetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strGetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strGetEnumValues failed: unknown result")

    def strGetValue(self, varName):
        """
        gets the value of a string variable

        Parameters:
         - varName

        """
        self.send_strGetValue(varName)
        return self.recv_strGetValue()

    def send_strGetValue(self, varName):
        self._oprot.writeMessageBegin('strGetValue', TMessageType.CALL, self._seqid)
        args = strGetValue_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strGetValue failed: unknown result")

    def strSetEnumAliases(self, varName, strVal):
        """
        sets the enumerated aliases with a comma-separated list

        Parameters:
         - varName
         - strVal

        """
        self.send_strSetEnumAliases(varName, strVal)
        self.recv_strSetEnumAliases()

    def send_strSetEnumAliases(self, varName, strVal):
        self._oprot.writeMessageBegin('strSetEnumAliases', TMessageType.CALL, self._seqid)
        args = strSetEnumAliases_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strSetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strSetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strSetEnumValues(self, varName, strVal):
        """
        sets the enumerated values with a comma-separated list

        Parameters:
         - varName
         - strVal

        """
        self.send_strSetEnumValues(varName, strVal)
        self.recv_strSetEnumValues()

    def send_strSetEnumValues(self, varName, strVal):
        self._oprot.writeMessageBegin('strSetEnumValues', TMessageType.CALL, self._seqid)
        args = strSetEnumValues_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strSetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strSetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strSetValue(self, varName, strVal):
        """
        sets the value of a string variable

        Parameters:
         - varName
         - strVal

        """
        self.send_strSetValue(varName, strVal)
        self.recv_strSetValue()

    def send_strSetValue(self, varName, strVal):
        self._oprot.writeMessageBegin('strSetValue', TMessageType.CALL, self._seqid)
        args = strSetValue_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strSetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strSetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strArrayFromString(self, varName, index, value):
        """
        converts a String representation to the internal value

        Parameters:
         - varName
         - index
         - value

        """
        self.send_strArrayFromString(varName, index, value)
        self.recv_strArrayFromString()

    def send_strArrayFromString(self, varName, index, value):
        self._oprot.writeMessageBegin('strArrayFromString', TMessageType.CALL, self._seqid)
        args = strArrayFromString_args()
        args.varName = varName
        args.index = index
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArrayFromString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArrayFromString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def strArrayGetEnumAliases(self, varName):
        """
        gets the enumerated aliases as a comma-separated list

        Parameters:
         - varName

        """
        self.send_strArrayGetEnumAliases(varName)
        return self.recv_strArrayGetEnumAliases()

    def send_strArrayGetEnumAliases(self, varName):
        self._oprot.writeMessageBegin('strArrayGetEnumAliases', TMessageType.CALL, self._seqid)
        args = strArrayGetEnumAliases_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArrayGetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArrayGetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strArrayGetEnumAliases failed: unknown result")

    def strArrayGetEnumValues(self, varName):
        """
        gets the value of a string variable

        Parameters:
         - varName

        """
        self.send_strArrayGetEnumValues(varName)
        return self.recv_strArrayGetEnumValues()

    def send_strArrayGetEnumValues(self, varName):
        self._oprot.writeMessageBegin('strArrayGetEnumValues', TMessageType.CALL, self._seqid)
        args = strArrayGetEnumValues_args()
        args.varName = varName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArrayGetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArrayGetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strArrayGetEnumValues failed: unknown result")

    def strArrayGetValue(self, varName, index):
        """
        sets the enumerated aliases with a comma-separated list

        Parameters:
         - varName
         - index

        """
        self.send_strArrayGetValue(varName, index)
        return self.recv_strArrayGetValue()

    def send_strArrayGetValue(self, varName, index):
        self._oprot.writeMessageBegin('strArrayGetValue', TMessageType.CALL, self._seqid)
        args = strArrayGetValue_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArrayGetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArrayGetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strArrayGetValue failed: unknown result")

    def strArraySetEnumAliases(self, varName, strVal):
        """
        sets the enumerated values with a comma-separated list

        Parameters:
         - varName
         - strVal

        """
        self.send_strArraySetEnumAliases(varName, strVal)
        self.recv_strArraySetEnumAliases()

    def send_strArraySetEnumAliases(self, varName, strVal):
        self._oprot.writeMessageBegin('strArraySetEnumAliases', TMessageType.CALL, self._seqid)
        args = strArraySetEnumAliases_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArraySetEnumAliases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArraySetEnumAliases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strArraySetEnumValues(self, varName, strVal):
        """
        sets the value of a string variable

        Parameters:
         - varName
         - strVal

        """
        self.send_strArraySetEnumValues(varName, strVal)
        self.recv_strArraySetEnumValues()

    def send_strArraySetEnumValues(self, varName, strVal):
        self._oprot.writeMessageBegin('strArraySetEnumValues', TMessageType.CALL, self._seqid)
        args = strArraySetEnumValues_args()
        args.varName = varName
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArraySetEnumValues(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArraySetEnumValues_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strArraySetValue(self, varName, index, strVal):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index
         - strVal

        """
        self.send_strArraySetValue(varName, index, strVal)
        self.recv_strArraySetValue()

    def send_strArraySetValue(self, varName, index, strVal):
        self._oprot.writeMessageBegin('strArraySetValue', TMessageType.CALL, self._seqid)
        args = strArraySetValue_args()
        args.varName = varName
        args.index = index
        args.strVal = strVal
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArraySetValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArraySetValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.generalError is not None:
            raise result.generalError
        return

    def strArrayToString(self, varName, index):
        """
        converts the variable to a string

        Parameters:
         - varName
         - index

        """
        self.send_strArrayToString(varName, index)
        return self.recv_strArrayToString()

    def send_strArrayToString(self, varName, index):
        self._oprot.writeMessageBegin('strArrayToString', TMessageType.CALL, self._seqid)
        args = strArrayToString_args()
        args.varName = varName
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_strArrayToString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = strArrayToString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.generalError is not None:
            raise result.generalError
        raise TApplicationException(TApplicationException.MISSING_RESULT, "strArrayToString failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["init"] = Processor.process_init
        self._processMap["initSuccess"] = Processor.process_initSuccess
        self._processMap["initFailed"] = Processor.process_initFailed
        self._processMap["GetNewRun"] = Processor.process_GetNewRun
        self._processMap["Success"] = Processor.process_Success
        self._processMap["Failed"] = Processor.process_Failed
        self._processMap["boolGetValue"] = Processor.process_boolGetValue
        self._processMap["boolSetValue"] = Processor.process_boolSetValue
        self._processMap["boolToString"] = Processor.process_boolToString
        self._processMap["boolArrayFromString"] = Processor.process_boolArrayFromString
        self._processMap["boolArrayGetValue"] = Processor.process_boolArrayGetValue
        self._processMap["boolArrayGetValueStr"] = Processor.process_boolArrayGetValueStr
        self._processMap["boolArraySetValue"] = Processor.process_boolArraySetValue
        self._processMap["boolArrayToString"] = Processor.process_boolArrayToString
        self._processMap["dblFromString"] = Processor.process_dblFromString
        self._processMap["dblGetEnumAliases"] = Processor.process_dblGetEnumAliases
        self._processMap["dblGetEnumValues"] = Processor.process_dblGetEnumValues
        self._processMap["dblGetFormat"] = Processor.process_dblGetFormat
        self._processMap["dblGetHasLowerBound"] = Processor.process_dblGetHasLowerBound
        self._processMap["dblGetHasUpperBound"] = Processor.process_dblGetHasUpperBound
        self._processMap["dblGetLowerBound"] = Processor.process_dblGetLowerBound
        self._processMap["dblGetUpperBound"] = Processor.process_dblGetUpperBound
        self._processMap["dblGetValue"] = Processor.process_dblGetValue
        self._processMap["dblSetEnumAliases"] = Processor.process_dblSetEnumAliases
        self._processMap["dblSetEnumValues"] = Processor.process_dblSetEnumValues
        self._processMap["dblSetFormat"] = Processor.process_dblSetFormat
        self._processMap["dblSetHasLowerBound"] = Processor.process_dblSetHasLowerBound
        self._processMap["dblSetHasUpperBound"] = Processor.process_dblSetHasUpperBound
        self._processMap["dblSetLowerBound"] = Processor.process_dblSetLowerBound
        self._processMap["dblSetUpperBound"] = Processor.process_dblSetUpperBound
        self._processMap["dblSetValue"] = Processor.process_dblSetValue
        self._processMap["dblToString"] = Processor.process_dblToString
        self._processMap["dblArrayFromString"] = Processor.process_dblArrayFromString
        self._processMap["dblArrayGetEnumAliases"] = Processor.process_dblArrayGetEnumAliases
        self._processMap["dblArrayGetEnumValues"] = Processor.process_dblArrayGetEnumValues
        self._processMap["dblArrayGetFormat"] = Processor.process_dblArrayGetFormat
        self._processMap["dblArrayGetHasLowerBound"] = Processor.process_dblArrayGetHasLowerBound
        self._processMap["dblArrayGetHasUpperBound"] = Processor.process_dblArrayGetHasUpperBound
        self._processMap["dblArrayGetLowerBound"] = Processor.process_dblArrayGetLowerBound
        self._processMap["dblArrayGetUpperBound"] = Processor.process_dblArrayGetUpperBound
        self._processMap["dblArrayGetValue"] = Processor.process_dblArrayGetValue
        self._processMap["dblArraySetEnumAliases"] = Processor.process_dblArraySetEnumAliases
        self._processMap["dblArraySetEnumValues"] = Processor.process_dblArraySetEnumValues
        self._processMap["dblArraySetFormat"] = Processor.process_dblArraySetFormat
        self._processMap["dblArraySetHasLowerBound"] = Processor.process_dblArraySetHasLowerBound
        self._processMap["dblArraySetHasUpperBound"] = Processor.process_dblArraySetHasUpperBound
        self._processMap["dblArraySetLowerBound"] = Processor.process_dblArraySetLowerBound
        self._processMap["dblArraySetUpperBound"] = Processor.process_dblArraySetUpperBound
        self._processMap["dblArraySetValue"] = Processor.process_dblArraySetValue
        self._processMap["dblArrayToString"] = Processor.process_dblArrayToString
        self._processMap["longFromString"] = Processor.process_longFromString
        self._processMap["longGetEnumAliases"] = Processor.process_longGetEnumAliases
        self._processMap["longGetEnumValues"] = Processor.process_longGetEnumValues
        self._processMap["longGetFormat"] = Processor.process_longGetFormat
        self._processMap["longGetHasLowerBound"] = Processor.process_longGetHasLowerBound
        self._processMap["longGetHasUpperBound"] = Processor.process_longGetHasUpperBound
        self._processMap["longGetLowerBound"] = Processor.process_longGetLowerBound
        self._processMap["longGetUpperBound"] = Processor.process_longGetUpperBound
        self._processMap["longGetValue"] = Processor.process_longGetValue
        self._processMap["longSetEnumAliases"] = Processor.process_longSetEnumAliases
        self._processMap["longSetEnumValues"] = Processor.process_longSetEnumValues
        self._processMap["longSetFormat"] = Processor.process_longSetFormat
        self._processMap["longSetHasLowerBound"] = Processor.process_longSetHasLowerBound
        self._processMap["longSetHasUpperBound"] = Processor.process_longSetHasUpperBound
        self._processMap["longSetLowerBound"] = Processor.process_longSetLowerBound
        self._processMap["longSetUpperBound"] = Processor.process_longSetUpperBound
        self._processMap["longSetValue"] = Processor.process_longSetValue
        self._processMap["longToString"] = Processor.process_longToString
        self._processMap["longArrayFromString"] = Processor.process_longArrayFromString
        self._processMap["longArrayGetEnumAliases"] = Processor.process_longArrayGetEnumAliases
        self._processMap["longArrayGetEnumValues"] = Processor.process_longArrayGetEnumValues
        self._processMap["longArrayGetFormat"] = Processor.process_longArrayGetFormat
        self._processMap["longArrayGetHasLowerBound"] = Processor.process_longArrayGetHasLowerBound
        self._processMap["longArrayGetHasUpperBound"] = Processor.process_longArrayGetHasUpperBound
        self._processMap["longArrayGetLowerBound"] = Processor.process_longArrayGetLowerBound
        self._processMap["longArrayGetUpperBound"] = Processor.process_longArrayGetUpperBound
        self._processMap["longArrayGetValue"] = Processor.process_longArrayGetValue
        self._processMap["longArraySetEnumAliases"] = Processor.process_longArraySetEnumAliases
        self._processMap["longArraySetEnumValues"] = Processor.process_longArraySetEnumValues
        self._processMap["longArraySetFormat"] = Processor.process_longArraySetFormat
        self._processMap["longArraySetHasLowerBound"] = Processor.process_longArraySetHasLowerBound
        self._processMap["longArraySetHasUpperBound"] = Processor.process_longArraySetHasUpperBound
        self._processMap["longArraySetLowerBound"] = Processor.process_longArraySetLowerBound
        self._processMap["longArraySetUpperBound"] = Processor.process_longArraySetUpperBound
        self._processMap["longArraySetValue"] = Processor.process_longArraySetValue
        self._processMap["longArrayToString"] = Processor.process_longArrayToString
        self._processMap["fileFromFile"] = Processor.process_fileFromFile
        self._processMap["fileFromString"] = Processor.process_fileFromString
        self._processMap["fileGetBaseName"] = Processor.process_fileGetBaseName
        self._processMap["fileGetContents"] = Processor.process_fileGetContents
        self._processMap["fileGetFileExtension"] = Processor.process_fileGetFileExtension
        self._processMap["fileGetIsBinary"] = Processor.process_fileGetIsBinary
        self._processMap["fileGetMimeType"] = Processor.process_fileGetMimeType
        self._processMap["fileGetName"] = Processor.process_fileGetName
        self._processMap["fileGetNameCoded"] = Processor.process_fileGetNameCoded
        self._processMap["fileHasChanged"] = Processor.process_fileHasChanged
        self._processMap["fileMarkAsRead"] = Processor.process_fileMarkAsRead
        self._processMap["fileSetBaseName"] = Processor.process_fileSetBaseName
        self._processMap["fileSetContents"] = Processor.process_fileSetContents
        self._processMap["fileSetFileExtension"] = Processor.process_fileSetFileExtension
        self._processMap["fileSetIsBinary"] = Processor.process_fileSetIsBinary
        self._processMap["fileSetMimeType"] = Processor.process_fileSetMimeType
        self._processMap["fileSetName"] = Processor.process_fileSetName
        self._processMap["fileToFile"] = Processor.process_fileToFile
        self._processMap["fileToString"] = Processor.process_fileToString
        self._processMap["fileArrayFromFile"] = Processor.process_fileArrayFromFile
        self._processMap["fileArrayFromString"] = Processor.process_fileArrayFromString
        self._processMap["fileArrayGetBaseName"] = Processor.process_fileArrayGetBaseName
        self._processMap["fileArrayGetContents"] = Processor.process_fileArrayGetContents
        self._processMap["fileArrayGetFileExtension"] = Processor.process_fileArrayGetFileExtension
        self._processMap["fileArrayGetIsBinary"] = Processor.process_fileArrayGetIsBinary
        self._processMap["fileArrayGetMimeType"] = Processor.process_fileArrayGetMimeType
        self._processMap["fileArrayGetName"] = Processor.process_fileArrayGetName
        self._processMap["fileArrayGetNameCoded"] = Processor.process_fileArrayGetNameCoded
        self._processMap["fileArrayHasChanged"] = Processor.process_fileArrayHasChanged
        self._processMap["fileArrayMarkAsRead"] = Processor.process_fileArrayMarkAsRead
        self._processMap["fileArraySetBaseName"] = Processor.process_fileArraySetBaseName
        self._processMap["fileArraySetContents"] = Processor.process_fileArraySetContents
        self._processMap["fileArraySetFileExtension"] = Processor.process_fileArraySetFileExtension
        self._processMap["fileArraySetIsBinary"] = Processor.process_fileArraySetIsBinary
        self._processMap["fileArraySetMimeType"] = Processor.process_fileArraySetMimeType
        self._processMap["fileArraySetName"] = Processor.process_fileArraySetName
        self._processMap["fileArrayToFile"] = Processor.process_fileArrayToFile
        self._processMap["fileArrayToString"] = Processor.process_fileArrayToString
        self._processMap["newPHXRowFieldFile"] = Processor.process_newPHXRowFieldFile
        self._processMap["rffClearMarks"] = Processor.process_rffClearMarks
        self._processMap["rffClose"] = Processor.process_rffClose
        self._processMap["rffDelete"] = Processor.process_rffDelete
        self._processMap["rffGenerate"] = Processor.process_rffGenerate
        self._processMap["rffMarkAsBeginning"] = Processor.process_rffMarkAsBeginning
        self._processMap["rffMarkAsEnd"] = Processor.process_rffMarkAsEnd
        self._processMap["rffReadDouble"] = Processor.process_rffReadDouble
        self._processMap["rffReadLong"] = Processor.process_rffReadLong
        self._processMap["rffReadValue"] = Processor.process_rffReadValue
        self._processMap["rffSetDelimiters"] = Processor.process_rffSetDelimiters
        self._processMap["rffSetFileToGenerateOrParse"] = Processor.process_rffSetFileToGenerateOrParse
        self._processMap["rffSetTemplateFile"] = Processor.process_rffSetTemplateFile
        self._processMap["rffTransferArray"] = Processor.process_rffTransferArray
        self._processMap["rffTransferKeyVar"] = Processor.process_rffTransferKeyVar
        self._processMap["rffTransferVar"] = Processor.process_rffTransferVar
        self._processMap["rffWriteValue"] = Processor.process_rffWriteValue
        self._processMap["runShareCleanTempDir"] = Processor.process_runShareCleanTempDir
        self._processMap["runShareGetBaseDirectory"] = Processor.process_runShareGetBaseDirectory
        self._processMap["runShareGetDirectory"] = Processor.process_runShareGetDirectory
        self._processMap["runShareHalt"] = Processor.process_runShareHalt
        self._processMap["runShareLock"] = Processor.process_runShareLock
        self._processMap["runShareRun"] = Processor.process_runShareRun
        self._processMap["runShareSetAutoDelete"] = Processor.process_runShareSetAutoDelete
        self._processMap["runShareSetFilesToCopy"] = Processor.process_runShareSetFilesToCopy
        self._processMap["runShareSetMode"] = Processor.process_runShareSetMode
        self._processMap["runShareUnlock"] = Processor.process_runShareUnlock
        self._processMap["objCallMethod"] = Processor.process_objCallMethod
        self._processMap["objDeleteAllMembers"] = Processor.process_objDeleteAllMembers
        self._processMap["objDeleteMember"] = Processor.process_objDeleteMember
        self._processMap["objFromFile"] = Processor.process_objFromFile
        self._processMap["objFromString"] = Processor.process_objFromString
        self._processMap["objFromXML"] = Processor.process_objFromXML
        self._processMap["objGetBooleanArrayMemberValue"] = Processor.process_objGetBooleanArrayMemberValue
        self._processMap["objGetBooleanMemberValue"] = Processor.process_objGetBooleanMemberValue
        self._processMap["objGetClassURL"] = Processor.process_objGetClassURL
        self._processMap["objGetDoubleArrayMemberValue"] = Processor.process_objGetDoubleArrayMemberValue
        self._processMap["objGetDoubleMemberValue"] = Processor.process_objGetDoubleMemberValue
        self._processMap["objGetFileName"] = Processor.process_objGetFileName
        self._processMap["objGetIntArrayMemberValue"] = Processor.process_objGetIntArrayMemberValue
        self._processMap["objGetIntMemberValue"] = Processor.process_objGetIntMemberValue
        self._processMap["objGetIsBinary"] = Processor.process_objGetIsBinary
        self._processMap["objGetMemberDescription"] = Processor.process_objGetMemberDescription
        self._processMap["objGetMemberDimensions"] = Processor.process_objGetMemberDimensions
        self._processMap["objGetMemberEnumAliases"] = Processor.process_objGetMemberEnumAliases
        self._processMap["objGetMemberEnumValues"] = Processor.process_objGetMemberEnumValues
        self._processMap["objGetMemberLength"] = Processor.process_objGetMemberLength
        self._processMap["objGetMemberLowerBound"] = Processor.process_objGetMemberLowerBound
        self._processMap["objGetMemberNumDimensions"] = Processor.process_objGetMemberNumDimensions
        self._processMap["objGetMemberProperty"] = Processor.process_objGetMemberProperty
        self._processMap["objGetMemberType"] = Processor.process_objGetMemberType
        self._processMap["objGetMemberUnits"] = Processor.process_objGetMemberUnits
        self._processMap["objGetMemberUpperBound"] = Processor.process_objGetMemberUpperBound
        self._processMap["objGetMemberValueAsString"] = Processor.process_objGetMemberValueAsString
        self._processMap["objGetStringArrayMemberValue"] = Processor.process_objGetStringArrayMemberValue
        self._processMap["objGetStringMemberValue"] = Processor.process_objGetStringMemberValue
        self._processMap["objHasMember"] = Processor.process_objHasMember
        self._processMap["objHasMemberLowerBound"] = Processor.process_objHasMemberLowerBound
        self._processMap["objHasMemberUpperBound"] = Processor.process_objHasMemberUpperBound
        self._processMap["objIsNonStrictType"] = Processor.process_objIsNonStrictType
        self._processMap["objSetBaseName"] = Processor.process_objSetBaseName
        self._processMap["objSetBooleanArrayMemberValue"] = Processor.process_objSetBooleanArrayMemberValue
        self._processMap["objSetBooleanMemberValue"] = Processor.process_objSetBooleanMemberValue
        self._processMap["objSetDoubleArrayMemberValue"] = Processor.process_objSetDoubleArrayMemberValue
        self._processMap["objSetDoubleMemberValue"] = Processor.process_objSetDoubleMemberValue
        self._processMap["objSetFileExtension"] = Processor.process_objSetFileExtension
        self._processMap["objSetFileName"] = Processor.process_objSetFileName
        self._processMap["objSetIntArrayMemberValue"] = Processor.process_objSetIntArrayMemberValue
        self._processMap["objSetIntMemberValue"] = Processor.process_objSetIntMemberValue
        self._processMap["objSetIsBinary"] = Processor.process_objSetIsBinary
        self._processMap["objSetMember"] = Processor.process_objSetMember
        self._processMap["objSetMemberDescription"] = Processor.process_objSetMemberDescription
        self._processMap["objSetMemberDimensions"] = Processor.process_objSetMemberDimensions
        self._processMap["objSetMemberEnumAliases"] = Processor.process_objSetMemberEnumAliases
        self._processMap["objSetMemberEnumValues"] = Processor.process_objSetMemberEnumValues
        self._processMap["objSetMemberLength"] = Processor.process_objSetMemberLength
        self._processMap["objSetMemberLowerBound"] = Processor.process_objSetMemberLowerBound
        self._processMap["objSetMemberProperty"] = Processor.process_objSetMemberProperty
        self._processMap["objSetMemberUnits"] = Processor.process_objSetMemberUnits
        self._processMap["objSetMemberUpperBound"] = Processor.process_objSetMemberUpperBound
        self._processMap["objSetMemberValueFromString"] = Processor.process_objSetMemberValueFromString
        self._processMap["objSetStringArrayMemberValue"] = Processor.process_objSetStringArrayMemberValue
        self._processMap["objSetStringMemberValue"] = Processor.process_objSetStringMemberValue
        self._processMap["objToFile"] = Processor.process_objToFile
        self._processMap["objToString"] = Processor.process_objToString
        self._processMap["objToXML"] = Processor.process_objToXML
        self._processMap["wrapperAddMethod"] = Processor.process_wrapperAddMethod
        self._processMap["wrapperAddVariable"] = Processor.process_wrapperAddVariable
        self._processMap["wrapperGetDictKey"] = Processor.process_wrapperGetDictKey
        self._processMap["wrapperGetDictNumEntries"] = Processor.process_wrapperGetDictNumEntries
        self._processMap["wrapperGetDictValue"] = Processor.process_wrapperGetDictValue
        self._processMap["wrapperGetDirectory"] = Processor.process_wrapperGetDirectory
        self._processMap["wrapperGetRunDirectory"] = Processor.process_wrapperGetRunDirectory
        self._processMap["wrapperGetVarType"] = Processor.process_wrapperGetVarType
        self._processMap["wrapperRemoveVariable"] = Processor.process_wrapperRemoveVariable
        self._processMap["wrapperSleep"] = Processor.process_wrapperSleep
        self._processMap["arrayFromString"] = Processor.process_arrayFromString
        self._processMap["arrayGetDimensions"] = Processor.process_arrayGetDimensions
        self._processMap["arrayGetLength"] = Processor.process_arrayGetLength
        self._processMap["arrayGetLockResize"] = Processor.process_arrayGetLockResize
        self._processMap["arrayGetNumDimensions"] = Processor.process_arrayGetNumDimensions
        self._processMap["arrayLockDimensions"] = Processor.process_arrayLockDimensions
        self._processMap["arraySetDimensions"] = Processor.process_arraySetDimensions
        self._processMap["arraySetLength"] = Processor.process_arraySetLength
        self._processMap["arraySetLockResize"] = Processor.process_arraySetLockResize
        self._processMap["arrayToString"] = Processor.process_arrayToString
        self._processMap["simpleGetDescription"] = Processor.process_simpleGetDescription
        self._processMap["simpleGetHasChanged"] = Processor.process_simpleGetHasChanged
        self._processMap["simpleGetUnits"] = Processor.process_simpleGetUnits
        self._processMap["simpleSetDescription"] = Processor.process_simpleSetDescription
        self._processMap["simpleSetHasChanged"] = Processor.process_simpleSetHasChanged
        self._processMap["simpleSetUnits"] = Processor.process_simpleSetUnits
        self._processMap["strGetEnumAliases"] = Processor.process_strGetEnumAliases
        self._processMap["strGetEnumValues"] = Processor.process_strGetEnumValues
        self._processMap["strGetValue"] = Processor.process_strGetValue
        self._processMap["strSetEnumAliases"] = Processor.process_strSetEnumAliases
        self._processMap["strSetEnumValues"] = Processor.process_strSetEnumValues
        self._processMap["strSetValue"] = Processor.process_strSetValue
        self._processMap["strArrayFromString"] = Processor.process_strArrayFromString
        self._processMap["strArrayGetEnumAliases"] = Processor.process_strArrayGetEnumAliases
        self._processMap["strArrayGetEnumValues"] = Processor.process_strArrayGetEnumValues
        self._processMap["strArrayGetValue"] = Processor.process_strArrayGetValue
        self._processMap["strArraySetEnumAliases"] = Processor.process_strArraySetEnumAliases
        self._processMap["strArraySetEnumValues"] = Processor.process_strArraySetEnumValues
        self._processMap["strArraySetValue"] = Processor.process_strArraySetValue
        self._processMap["strArrayToString"] = Processor.process_strArrayToString
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_init(self, seqid, iprot, oprot):
        args = init_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = init_result()
        try:
            result.success = self._handler.init(args.epoch)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("init", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initSuccess(self, seqid, iprot, oprot):
        args = initSuccess_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initSuccess_result()
        try:
            self._handler.initSuccess()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initSuccess", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initFailed(self, seqid, iprot, oprot):
        args = initFailed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initFailed_result()
        try:
            self._handler.initFailed(args.error)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initFailed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetNewRun(self, seqid, iprot, oprot):
        args = GetNewRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetNewRun_result()
        try:
            result.success = self._handler.GetNewRun()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetNewRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Success(self, seqid, iprot, oprot):
        args = Success_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Success_result()
        try:
            self._handler.Success()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Success", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Failed(self, seqid, iprot, oprot):
        args = Failed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Failed_result()
        try:
            self._handler.Failed(args.error)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Failed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolGetValue(self, seqid, iprot, oprot):
        args = boolGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolGetValue_result()
        try:
            result.success = self._handler.boolGetValue(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolSetValue(self, seqid, iprot, oprot):
        args = boolSetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolSetValue_result()
        try:
            self._handler.boolSetValue(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolSetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolToString(self, seqid, iprot, oprot):
        args = boolToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolToString_result()
        try:
            result.success = self._handler.boolToString(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolArrayFromString(self, seqid, iprot, oprot):
        args = boolArrayFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolArrayFromString_result()
        try:
            self._handler.boolArrayFromString(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolArrayFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolArrayGetValue(self, seqid, iprot, oprot):
        args = boolArrayGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolArrayGetValue_result()
        try:
            result.success = self._handler.boolArrayGetValue(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolArrayGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolArrayGetValueStr(self, seqid, iprot, oprot):
        args = boolArrayGetValueStr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolArrayGetValueStr_result()
        try:
            result.success = self._handler.boolArrayGetValueStr(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolArrayGetValueStr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolArraySetValue(self, seqid, iprot, oprot):
        args = boolArraySetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolArraySetValue_result()
        try:
            self._handler.boolArraySetValue(args.varName, args.index, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolArraySetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_boolArrayToString(self, seqid, iprot, oprot):
        args = boolArrayToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = boolArrayToString_result()
        try:
            result.success = self._handler.boolArrayToString(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("boolArrayToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblFromString(self, seqid, iprot, oprot):
        args = dblFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblFromString_result()
        try:
            self._handler.dblFromString(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetEnumAliases(self, seqid, iprot, oprot):
        args = dblGetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetEnumAliases_result()
        try:
            result.success = self._handler.dblGetEnumAliases(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetEnumValues(self, seqid, iprot, oprot):
        args = dblGetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetEnumValues_result()
        try:
            result.success = self._handler.dblGetEnumValues(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetFormat(self, seqid, iprot, oprot):
        args = dblGetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetFormat_result()
        try:
            result.success = self._handler.dblGetFormat(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetHasLowerBound(self, seqid, iprot, oprot):
        args = dblGetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetHasLowerBound_result()
        try:
            result.success = self._handler.dblGetHasLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetHasUpperBound(self, seqid, iprot, oprot):
        args = dblGetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetHasUpperBound_result()
        try:
            result.success = self._handler.dblGetHasUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetLowerBound(self, seqid, iprot, oprot):
        args = dblGetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetLowerBound_result()
        try:
            result.success = self._handler.dblGetLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetUpperBound(self, seqid, iprot, oprot):
        args = dblGetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetUpperBound_result()
        try:
            result.success = self._handler.dblGetUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblGetValue(self, seqid, iprot, oprot):
        args = dblGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblGetValue_result()
        try:
            result.success = self._handler.dblGetValue(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetEnumAliases(self, seqid, iprot, oprot):
        args = dblSetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetEnumAliases_result()
        try:
            self._handler.dblSetEnumAliases(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetEnumValues(self, seqid, iprot, oprot):
        args = dblSetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetEnumValues_result()
        try:
            self._handler.dblSetEnumValues(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetFormat(self, seqid, iprot, oprot):
        args = dblSetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetFormat_result()
        try:
            self._handler.dblSetFormat(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetHasLowerBound(self, seqid, iprot, oprot):
        args = dblSetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetHasLowerBound_result()
        try:
            self._handler.dblSetHasLowerBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetHasUpperBound(self, seqid, iprot, oprot):
        args = dblSetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetHasUpperBound_result()
        try:
            self._handler.dblSetHasUpperBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetLowerBound(self, seqid, iprot, oprot):
        args = dblSetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetLowerBound_result()
        try:
            self._handler.dblSetLowerBound(args.varName, args.dblVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetUpperBound(self, seqid, iprot, oprot):
        args = dblSetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetUpperBound_result()
        try:
            self._handler.dblSetUpperBound(args.varName, args.dblVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblSetValue(self, seqid, iprot, oprot):
        args = dblSetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblSetValue_result()
        try:
            self._handler.dblSetValue(args.varName, args.dblVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblSetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblToString(self, seqid, iprot, oprot):
        args = dblToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblToString_result()
        try:
            result.success = self._handler.dblToString(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayFromString(self, seqid, iprot, oprot):
        args = dblArrayFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayFromString_result()
        try:
            self._handler.dblArrayFromString(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetEnumAliases(self, seqid, iprot, oprot):
        args = dblArrayGetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetEnumAliases_result()
        try:
            result.success = self._handler.dblArrayGetEnumAliases(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetEnumValues(self, seqid, iprot, oprot):
        args = dblArrayGetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetEnumValues_result()
        try:
            result.success = self._handler.dblArrayGetEnumValues(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetFormat(self, seqid, iprot, oprot):
        args = dblArrayGetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetFormat_result()
        try:
            result.success = self._handler.dblArrayGetFormat(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetHasLowerBound(self, seqid, iprot, oprot):
        args = dblArrayGetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetHasLowerBound_result()
        try:
            result.success = self._handler.dblArrayGetHasLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetHasUpperBound(self, seqid, iprot, oprot):
        args = dblArrayGetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetHasUpperBound_result()
        try:
            result.success = self._handler.dblArrayGetHasUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetLowerBound(self, seqid, iprot, oprot):
        args = dblArrayGetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetLowerBound_result()
        try:
            result.success = self._handler.dblArrayGetLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetUpperBound(self, seqid, iprot, oprot):
        args = dblArrayGetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetUpperBound_result()
        try:
            result.success = self._handler.dblArrayGetUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayGetValue(self, seqid, iprot, oprot):
        args = dblArrayGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayGetValue_result()
        try:
            result.success = self._handler.dblArrayGetValue(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetEnumAliases(self, seqid, iprot, oprot):
        args = dblArraySetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetEnumAliases_result()
        try:
            self._handler.dblArraySetEnumAliases(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetEnumValues(self, seqid, iprot, oprot):
        args = dblArraySetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetEnumValues_result()
        try:
            self._handler.dblArraySetEnumValues(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetFormat(self, seqid, iprot, oprot):
        args = dblArraySetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetFormat_result()
        try:
            self._handler.dblArraySetFormat(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetHasLowerBound(self, seqid, iprot, oprot):
        args = dblArraySetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetHasLowerBound_result()
        try:
            self._handler.dblArraySetHasLowerBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetHasUpperBound(self, seqid, iprot, oprot):
        args = dblArraySetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetHasUpperBound_result()
        try:
            self._handler.dblArraySetHasUpperBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetLowerBound(self, seqid, iprot, oprot):
        args = dblArraySetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetLowerBound_result()
        try:
            self._handler.dblArraySetLowerBound(args.varName, args.dblVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetUpperBound(self, seqid, iprot, oprot):
        args = dblArraySetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetUpperBound_result()
        try:
            self._handler.dblArraySetUpperBound(args.varName, args.dblVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArraySetValue(self, seqid, iprot, oprot):
        args = dblArraySetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArraySetValue_result()
        try:
            self._handler.dblArraySetValue(args.varName, args.index, args.dblVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArraySetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dblArrayToString(self, seqid, iprot, oprot):
        args = dblArrayToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dblArrayToString_result()
        try:
            result.success = self._handler.dblArrayToString(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dblArrayToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longFromString(self, seqid, iprot, oprot):
        args = longFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longFromString_result()
        try:
            self._handler.longFromString(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetEnumAliases(self, seqid, iprot, oprot):
        args = longGetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetEnumAliases_result()
        try:
            result.success = self._handler.longGetEnumAliases(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetEnumValues(self, seqid, iprot, oprot):
        args = longGetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetEnumValues_result()
        try:
            result.success = self._handler.longGetEnumValues(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetFormat(self, seqid, iprot, oprot):
        args = longGetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetFormat_result()
        try:
            result.success = self._handler.longGetFormat(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetHasLowerBound(self, seqid, iprot, oprot):
        args = longGetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetHasLowerBound_result()
        try:
            result.success = self._handler.longGetHasLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetHasUpperBound(self, seqid, iprot, oprot):
        args = longGetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetHasUpperBound_result()
        try:
            result.success = self._handler.longGetHasUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetLowerBound(self, seqid, iprot, oprot):
        args = longGetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetLowerBound_result()
        try:
            result.success = self._handler.longGetLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetUpperBound(self, seqid, iprot, oprot):
        args = longGetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetUpperBound_result()
        try:
            result.success = self._handler.longGetUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longGetValue(self, seqid, iprot, oprot):
        args = longGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longGetValue_result()
        try:
            result.success = self._handler.longGetValue(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetEnumAliases(self, seqid, iprot, oprot):
        args = longSetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetEnumAliases_result()
        try:
            self._handler.longSetEnumAliases(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetEnumValues(self, seqid, iprot, oprot):
        args = longSetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetEnumValues_result()
        try:
            self._handler.longSetEnumValues(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetFormat(self, seqid, iprot, oprot):
        args = longSetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetFormat_result()
        try:
            self._handler.longSetFormat(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetHasLowerBound(self, seqid, iprot, oprot):
        args = longSetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetHasLowerBound_result()
        try:
            self._handler.longSetHasLowerBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetHasUpperBound(self, seqid, iprot, oprot):
        args = longSetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetHasUpperBound_result()
        try:
            self._handler.longSetHasUpperBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetLowerBound(self, seqid, iprot, oprot):
        args = longSetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetLowerBound_result()
        try:
            self._handler.longSetLowerBound(args.varName, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetUpperBound(self, seqid, iprot, oprot):
        args = longSetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetUpperBound_result()
        try:
            self._handler.longSetUpperBound(args.varName, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longSetValue(self, seqid, iprot, oprot):
        args = longSetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longSetValue_result()
        try:
            self._handler.longSetValue(args.varName, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longSetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longToString(self, seqid, iprot, oprot):
        args = longToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longToString_result()
        try:
            result.success = self._handler.longToString(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayFromString(self, seqid, iprot, oprot):
        args = longArrayFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayFromString_result()
        try:
            self._handler.longArrayFromString(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetEnumAliases(self, seqid, iprot, oprot):
        args = longArrayGetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetEnumAliases_result()
        try:
            result.success = self._handler.longArrayGetEnumAliases(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetEnumValues(self, seqid, iprot, oprot):
        args = longArrayGetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetEnumValues_result()
        try:
            result.success = self._handler.longArrayGetEnumValues(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetFormat(self, seqid, iprot, oprot):
        args = longArrayGetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetFormat_result()
        try:
            result.success = self._handler.longArrayGetFormat(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetHasLowerBound(self, seqid, iprot, oprot):
        args = longArrayGetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetHasLowerBound_result()
        try:
            result.success = self._handler.longArrayGetHasLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetHasUpperBound(self, seqid, iprot, oprot):
        args = longArrayGetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetHasUpperBound_result()
        try:
            result.success = self._handler.longArrayGetHasUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetLowerBound(self, seqid, iprot, oprot):
        args = longArrayGetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetLowerBound_result()
        try:
            result.success = self._handler.longArrayGetLowerBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetUpperBound(self, seqid, iprot, oprot):
        args = longArrayGetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetUpperBound_result()
        try:
            result.success = self._handler.longArrayGetUpperBound(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayGetValue(self, seqid, iprot, oprot):
        args = longArrayGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayGetValue_result()
        try:
            result.success = self._handler.longArrayGetValue(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetEnumAliases(self, seqid, iprot, oprot):
        args = longArraySetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetEnumAliases_result()
        try:
            self._handler.longArraySetEnumAliases(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetEnumValues(self, seqid, iprot, oprot):
        args = longArraySetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetEnumValues_result()
        try:
            self._handler.longArraySetEnumValues(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetFormat(self, seqid, iprot, oprot):
        args = longArraySetFormat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetFormat_result()
        try:
            self._handler.longArraySetFormat(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetFormat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetHasLowerBound(self, seqid, iprot, oprot):
        args = longArraySetHasLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetHasLowerBound_result()
        try:
            self._handler.longArraySetHasLowerBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetHasLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetHasUpperBound(self, seqid, iprot, oprot):
        args = longArraySetHasUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetHasUpperBound_result()
        try:
            self._handler.longArraySetHasUpperBound(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetHasUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetLowerBound(self, seqid, iprot, oprot):
        args = longArraySetLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetLowerBound_result()
        try:
            self._handler.longArraySetLowerBound(args.varName, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetUpperBound(self, seqid, iprot, oprot):
        args = longArraySetUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetUpperBound_result()
        try:
            self._handler.longArraySetUpperBound(args.varName, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArraySetValue(self, seqid, iprot, oprot):
        args = longArraySetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArraySetValue_result()
        try:
            self._handler.longArraySetValue(args.varName, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArraySetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_longArrayToString(self, seqid, iprot, oprot):
        args = longArrayToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = longArrayToString_result()
        try:
            result.success = self._handler.longArrayToString(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("longArrayToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileFromFile(self, seqid, iprot, oprot):
        args = fileFromFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileFromFile_result()
        try:
            self._handler.fileFromFile(args.varName, args.fileName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileFromFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileFromString(self, seqid, iprot, oprot):
        args = fileFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileFromString_result()
        try:
            self._handler.fileFromString(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetBaseName(self, seqid, iprot, oprot):
        args = fileGetBaseName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetBaseName_result()
        try:
            result.success = self._handler.fileGetBaseName(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetBaseName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetContents(self, seqid, iprot, oprot):
        args = fileGetContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetContents_result()
        try:
            result.success = self._handler.fileGetContents(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetFileExtension(self, seqid, iprot, oprot):
        args = fileGetFileExtension_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetFileExtension_result()
        try:
            result.success = self._handler.fileGetFileExtension(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetFileExtension", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetIsBinary(self, seqid, iprot, oprot):
        args = fileGetIsBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetIsBinary_result()
        try:
            result.success = self._handler.fileGetIsBinary(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetIsBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetMimeType(self, seqid, iprot, oprot):
        args = fileGetMimeType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetMimeType_result()
        try:
            result.success = self._handler.fileGetMimeType(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetMimeType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetName(self, seqid, iprot, oprot):
        args = fileGetName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetName_result()
        try:
            result.success = self._handler.fileGetName(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileGetNameCoded(self, seqid, iprot, oprot):
        args = fileGetNameCoded_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileGetNameCoded_result()
        try:
            result.success = self._handler.fileGetNameCoded(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileGetNameCoded", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileHasChanged(self, seqid, iprot, oprot):
        args = fileHasChanged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileHasChanged_result()
        try:
            result.success = self._handler.fileHasChanged(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileHasChanged", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileMarkAsRead(self, seqid, iprot, oprot):
        args = fileMarkAsRead_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileMarkAsRead_result()
        try:
            self._handler.fileMarkAsRead(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileMarkAsRead", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileSetBaseName(self, seqid, iprot, oprot):
        args = fileSetBaseName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileSetBaseName_result()
        try:
            self._handler.fileSetBaseName(args.varName, args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileSetBaseName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileSetContents(self, seqid, iprot, oprot):
        args = fileSetContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileSetContents_result()
        try:
            self._handler.fileSetContents(args.varName, args.contents)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileSetContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileSetFileExtension(self, seqid, iprot, oprot):
        args = fileSetFileExtension_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileSetFileExtension_result()
        try:
            self._handler.fileSetFileExtension(args.varName, args.extension)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileSetFileExtension", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileSetIsBinary(self, seqid, iprot, oprot):
        args = fileSetIsBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileSetIsBinary_result()
        try:
            self._handler.fileSetIsBinary(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileSetIsBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileSetMimeType(self, seqid, iprot, oprot):
        args = fileSetMimeType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileSetMimeType_result()
        try:
            self._handler.fileSetMimeType(args.varName, args.mimeType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileSetMimeType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileSetName(self, seqid, iprot, oprot):
        args = fileSetName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileSetName_result()
        try:
            self._handler.fileSetName(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileSetName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileToFile(self, seqid, iprot, oprot):
        args = fileToFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileToFile_result()
        try:
            self._handler.fileToFile(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileToFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileToString(self, seqid, iprot, oprot):
        args = fileToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileToString_result()
        try:
            result.success = self._handler.fileToString(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayFromFile(self, seqid, iprot, oprot):
        args = fileArrayFromFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayFromFile_result()
        try:
            self._handler.fileArrayFromFile(args.varName, args.index, args.fileName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayFromFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayFromString(self, seqid, iprot, oprot):
        args = fileArrayFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayFromString_result()
        try:
            self._handler.fileArrayFromString(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetBaseName(self, seqid, iprot, oprot):
        args = fileArrayGetBaseName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetBaseName_result()
        try:
            result.success = self._handler.fileArrayGetBaseName(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetBaseName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetContents(self, seqid, iprot, oprot):
        args = fileArrayGetContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetContents_result()
        try:
            result.success = self._handler.fileArrayGetContents(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetFileExtension(self, seqid, iprot, oprot):
        args = fileArrayGetFileExtension_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetFileExtension_result()
        try:
            result.success = self._handler.fileArrayGetFileExtension(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetFileExtension", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetIsBinary(self, seqid, iprot, oprot):
        args = fileArrayGetIsBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetIsBinary_result()
        try:
            result.success = self._handler.fileArrayGetIsBinary(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetIsBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetMimeType(self, seqid, iprot, oprot):
        args = fileArrayGetMimeType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetMimeType_result()
        try:
            result.success = self._handler.fileArrayGetMimeType(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetMimeType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetName(self, seqid, iprot, oprot):
        args = fileArrayGetName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetName_result()
        try:
            result.success = self._handler.fileArrayGetName(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayGetNameCoded(self, seqid, iprot, oprot):
        args = fileArrayGetNameCoded_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayGetNameCoded_result()
        try:
            result.success = self._handler.fileArrayGetNameCoded(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayGetNameCoded", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayHasChanged(self, seqid, iprot, oprot):
        args = fileArrayHasChanged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayHasChanged_result()
        try:
            result.success = self._handler.fileArrayHasChanged(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayHasChanged", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayMarkAsRead(self, seqid, iprot, oprot):
        args = fileArrayMarkAsRead_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayMarkAsRead_result()
        try:
            self._handler.fileArrayMarkAsRead(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayMarkAsRead", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArraySetBaseName(self, seqid, iprot, oprot):
        args = fileArraySetBaseName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArraySetBaseName_result()
        try:
            self._handler.fileArraySetBaseName(args.varName, args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArraySetBaseName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArraySetContents(self, seqid, iprot, oprot):
        args = fileArraySetContents_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArraySetContents_result()
        try:
            self._handler.fileArraySetContents(args.varName, args.index, args.contents)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArraySetContents", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArraySetFileExtension(self, seqid, iprot, oprot):
        args = fileArraySetFileExtension_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArraySetFileExtension_result()
        try:
            self._handler.fileArraySetFileExtension(args.varName, args.index, args.extension)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArraySetFileExtension", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArraySetIsBinary(self, seqid, iprot, oprot):
        args = fileArraySetIsBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArraySetIsBinary_result()
        try:
            self._handler.fileArraySetIsBinary(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArraySetIsBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArraySetMimeType(self, seqid, iprot, oprot):
        args = fileArraySetMimeType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArraySetMimeType_result()
        try:
            self._handler.fileArraySetMimeType(args.varName, args.mimeType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArraySetMimeType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArraySetName(self, seqid, iprot, oprot):
        args = fileArraySetName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArraySetName_result()
        try:
            self._handler.fileArraySetName(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArraySetName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayToFile(self, seqid, iprot, oprot):
        args = fileArrayToFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayToFile_result()
        try:
            self._handler.fileArrayToFile(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayToFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fileArrayToString(self, seqid, iprot, oprot):
        args = fileArrayToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fileArrayToString_result()
        try:
            result.success = self._handler.fileArrayToString(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fileArrayToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_newPHXRowFieldFile(self, seqid, iprot, oprot):
        args = newPHXRowFieldFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = newPHXRowFieldFile_result()
        try:
            result.success = self._handler.newPHXRowFieldFile(args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("newPHXRowFieldFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffClearMarks(self, seqid, iprot, oprot):
        args = rffClearMarks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffClearMarks_result()
        try:
            self._handler.rffClearMarks(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffClearMarks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffClose(self, seqid, iprot, oprot):
        args = rffClose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffClose_result()
        try:
            self._handler.rffClose(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffClose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffDelete(self, seqid, iprot, oprot):
        args = rffDelete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffDelete_result()
        try:
            self._handler.rffDelete(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffDelete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffGenerate(self, seqid, iprot, oprot):
        args = rffGenerate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffGenerate_result()
        try:
            self._handler.rffGenerate(args.key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffGenerate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffMarkAsBeginning(self, seqid, iprot, oprot):
        args = rffMarkAsBeginning_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffMarkAsBeginning_result()
        try:
            self._handler.rffMarkAsBeginning(args.key, args.find, args.occurrence, args.offset, args.regex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffMarkAsBeginning", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffMarkAsEnd(self, seqid, iprot, oprot):
        args = rffMarkAsEnd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffMarkAsEnd_result()
        try:
            self._handler.rffMarkAsEnd(args.key, args.find, args.occurrence, args.offset, args.regex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffMarkAsEnd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffReadDouble(self, seqid, iprot, oprot):
        args = rffReadDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffReadDouble_result()
        try:
            result.success = self._handler.rffReadDouble(args.key, args.row, args.field)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffReadDouble", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffReadLong(self, seqid, iprot, oprot):
        args = rffReadLong_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffReadLong_result()
        try:
            result.success = self._handler.rffReadLong(args.key, args.row, args.field)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffReadLong", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffReadValue(self, seqid, iprot, oprot):
        args = rffReadValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffReadValue_result()
        try:
            result.success = self._handler.rffReadValue(args.key, args.row, args.field)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffReadValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffSetDelimiters(self, seqid, iprot, oprot):
        args = rffSetDelimiters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffSetDelimiters_result()
        try:
            self._handler.rffSetDelimiters(args.key, args.delimiters)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffSetDelimiters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffSetFileToGenerateOrParse(self, seqid, iprot, oprot):
        args = rffSetFileToGenerateOrParse_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffSetFileToGenerateOrParse_result()
        try:
            self._handler.rffSetFileToGenerateOrParse(args.key, args.fileName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffSetFileToGenerateOrParse", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffSetTemplateFile(self, seqid, iprot, oprot):
        args = rffSetTemplateFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffSetTemplateFile_result()
        try:
            self._handler.rffSetTemplateFile(args.key, args.fileName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffSetTemplateFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffTransferArray(self, seqid, iprot, oprot):
        args = rffTransferArray_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffTransferArray_result()
        try:
            self._handler.rffTransferArray(args.key, args.varName, args.rowstart, args.rowend, args.fieldstart, args.fieldend, args.resizable, args.format, args.numDimensions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffTransferArray", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffTransferKeyVar(self, seqid, iprot, oprot):
        args = rffTransferKeyVar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffTransferKeyVar_result()
        try:
            self._handler.rffTransferKeyVar(args.key, args.varName, args.searchKey, args.occurrence, args.rowOffset, args.field, args.fformat)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffTransferKeyVar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffTransferVar(self, seqid, iprot, oprot):
        args = rffTransferVar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffTransferVar_result()
        try:
            self._handler.rffTransferVar(args.key, args.varName, args.row, args.field, args.format)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffTransferVar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rffWriteValue(self, seqid, iprot, oprot):
        args = rffWriteValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rffWriteValue_result()
        try:
            self._handler.rffWriteValue(args.key, args.row, args.field, args.val)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rffWriteValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareCleanTempDir(self, seqid, iprot, oprot):
        args = runShareCleanTempDir_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareCleanTempDir_result()
        try:
            self._handler.runShareCleanTempDir()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareCleanTempDir", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareGetBaseDirectory(self, seqid, iprot, oprot):
        args = runShareGetBaseDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareGetBaseDirectory_result()
        try:
            result.success = self._handler.runShareGetBaseDirectory()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareGetBaseDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareGetDirectory(self, seqid, iprot, oprot):
        args = runShareGetDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareGetDirectory_result()
        try:
            result.success = self._handler.runShareGetDirectory()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareGetDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareHalt(self, seqid, iprot, oprot):
        args = runShareHalt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareHalt_result()
        try:
            self._handler.runShareHalt()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareHalt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareLock(self, seqid, iprot, oprot):
        args = runShareLock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareLock_result()
        try:
            self._handler.runShareLock()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareLock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareRun(self, seqid, iprot, oprot):
        args = runShareRun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareRun_result()
        try:
            self._handler.runShareRun(args.cmd, args.ignoreErrors, args.autoChangeDir, args.shell)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareRun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareSetAutoDelete(self, seqid, iprot, oprot):
        args = runShareSetAutoDelete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareSetAutoDelete_result()
        try:
            self._handler.runShareSetAutoDelete(args.autoDelete)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareSetAutoDelete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareSetFilesToCopy(self, seqid, iprot, oprot):
        args = runShareSetFilesToCopy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareSetFilesToCopy_result()
        try:
            self._handler.runShareSetFilesToCopy(args.files)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareSetFilesToCopy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareSetMode(self, seqid, iprot, oprot):
        args = runShareSetMode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareSetMode_result()
        try:
            self._handler.runShareSetMode(args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareSetMode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_runShareUnlock(self, seqid, iprot, oprot):
        args = runShareUnlock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = runShareUnlock_result()
        try:
            self._handler.runShareUnlock()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("runShareUnlock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objCallMethod(self, seqid, iprot, oprot):
        args = objCallMethod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objCallMethod_result()
        try:
            self._handler.objCallMethod(args.varName, args.method)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objCallMethod", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objDeleteAllMembers(self, seqid, iprot, oprot):
        args = objDeleteAllMembers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objDeleteAllMembers_result()
        try:
            self._handler.objDeleteAllMembers(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objDeleteAllMembers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objDeleteMember(self, seqid, iprot, oprot):
        args = objDeleteMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objDeleteMember_result()
        try:
            self._handler.objDeleteMember(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objDeleteMember", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objFromFile(self, seqid, iprot, oprot):
        args = objFromFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objFromFile_result()
        try:
            self._handler.objFromFile(args.varName, args.mIndex, args.fileName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objFromFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objFromString(self, seqid, iprot, oprot):
        args = objFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objFromString_result()
        try:
            self._handler.objFromString(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objFromXML(self, seqid, iprot, oprot):
        args = objFromXML_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objFromXML_result()
        try:
            self._handler.objFromXML(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objFromXML", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetBooleanArrayMemberValue(self, seqid, iprot, oprot):
        args = objGetBooleanArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetBooleanArrayMemberValue_result()
        try:
            result.success = self._handler.objGetBooleanArrayMemberValue(args.varName, args.mIndex, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetBooleanArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetBooleanMemberValue(self, seqid, iprot, oprot):
        args = objGetBooleanMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetBooleanMemberValue_result()
        try:
            result.success = self._handler.objGetBooleanMemberValue(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetBooleanMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetClassURL(self, seqid, iprot, oprot):
        args = objGetClassURL_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetClassURL_result()
        try:
            result.success = self._handler.objGetClassURL(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetClassURL", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetDoubleArrayMemberValue(self, seqid, iprot, oprot):
        args = objGetDoubleArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetDoubleArrayMemberValue_result()
        try:
            result.success = self._handler.objGetDoubleArrayMemberValue(args.varName, args.mIndex, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetDoubleArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetDoubleMemberValue(self, seqid, iprot, oprot):
        args = objGetDoubleMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetDoubleMemberValue_result()
        try:
            result.success = self._handler.objGetDoubleMemberValue(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetDoubleMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetFileName(self, seqid, iprot, oprot):
        args = objGetFileName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetFileName_result()
        try:
            result.success = self._handler.objGetFileName(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetFileName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetIntArrayMemberValue(self, seqid, iprot, oprot):
        args = objGetIntArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetIntArrayMemberValue_result()
        try:
            result.success = self._handler.objGetIntArrayMemberValue(args.varName, args.mIndex, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetIntArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetIntMemberValue(self, seqid, iprot, oprot):
        args = objGetIntMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetIntMemberValue_result()
        try:
            result.success = self._handler.objGetIntMemberValue(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetIntMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetIsBinary(self, seqid, iprot, oprot):
        args = objGetIsBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetIsBinary_result()
        try:
            result.success = self._handler.objGetIsBinary(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetIsBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberDescription(self, seqid, iprot, oprot):
        args = objGetMemberDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberDescription_result()
        try:
            result.success = self._handler.objGetMemberDescription(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberDimensions(self, seqid, iprot, oprot):
        args = objGetMemberDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberDimensions_result()
        try:
            result.success = self._handler.objGetMemberDimensions(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberEnumAliases(self, seqid, iprot, oprot):
        args = objGetMemberEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberEnumAliases_result()
        try:
            result.success = self._handler.objGetMemberEnumAliases(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberEnumValues(self, seqid, iprot, oprot):
        args = objGetMemberEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberEnumValues_result()
        try:
            result.success = self._handler.objGetMemberEnumValues(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberLength(self, seqid, iprot, oprot):
        args = objGetMemberLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberLength_result()
        try:
            result.success = self._handler.objGetMemberLength(args.varName, args.mIndex, args.dim)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberLowerBound(self, seqid, iprot, oprot):
        args = objGetMemberLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberLowerBound_result()
        try:
            result.success = self._handler.objGetMemberLowerBound(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberNumDimensions(self, seqid, iprot, oprot):
        args = objGetMemberNumDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberNumDimensions_result()
        try:
            result.success = self._handler.objGetMemberNumDimensions(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberNumDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberProperty(self, seqid, iprot, oprot):
        args = objGetMemberProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberProperty_result()
        try:
            result.success = self._handler.objGetMemberProperty(args.varName, args.mIndex, args.propertyName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberType(self, seqid, iprot, oprot):
        args = objGetMemberType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberType_result()
        try:
            result.success = self._handler.objGetMemberType(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberUnits(self, seqid, iprot, oprot):
        args = objGetMemberUnits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberUnits_result()
        try:
            result.success = self._handler.objGetMemberUnits(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberUnits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberUpperBound(self, seqid, iprot, oprot):
        args = objGetMemberUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberUpperBound_result()
        try:
            result.success = self._handler.objGetMemberUpperBound(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetMemberValueAsString(self, seqid, iprot, oprot):
        args = objGetMemberValueAsString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetMemberValueAsString_result()
        try:
            result.success = self._handler.objGetMemberValueAsString(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetMemberValueAsString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetStringArrayMemberValue(self, seqid, iprot, oprot):
        args = objGetStringArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetStringArrayMemberValue_result()
        try:
            result.success = self._handler.objGetStringArrayMemberValue(args.varName, args.mIndex, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetStringArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objGetStringMemberValue(self, seqid, iprot, oprot):
        args = objGetStringMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objGetStringMemberValue_result()
        try:
            result.success = self._handler.objGetStringMemberValue(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objGetStringMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objHasMember(self, seqid, iprot, oprot):
        args = objHasMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objHasMember_result()
        try:
            result.success = self._handler.objHasMember(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objHasMember", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objHasMemberLowerBound(self, seqid, iprot, oprot):
        args = objHasMemberLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objHasMemberLowerBound_result()
        try:
            result.success = self._handler.objHasMemberLowerBound(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objHasMemberLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objHasMemberUpperBound(self, seqid, iprot, oprot):
        args = objHasMemberUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objHasMemberUpperBound_result()
        try:
            result.success = self._handler.objHasMemberUpperBound(args.varName, args.mIndex)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objHasMemberUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objIsNonStrictType(self, seqid, iprot, oprot):
        args = objIsNonStrictType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objIsNonStrictType_result()
        try:
            result.success = self._handler.objIsNonStrictType(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objIsNonStrictType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetBaseName(self, seqid, iprot, oprot):
        args = objSetBaseName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetBaseName_result()
        try:
            self._handler.objSetBaseName(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetBaseName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetBooleanArrayMemberValue(self, seqid, iprot, oprot):
        args = objSetBooleanArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetBooleanArrayMemberValue_result()
        try:
            self._handler.objSetBooleanArrayMemberValue(args.varName, args.mIndex, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetBooleanArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetBooleanMemberValue(self, seqid, iprot, oprot):
        args = objSetBooleanMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetBooleanMemberValue_result()
        try:
            self._handler.objSetBooleanMemberValue(args.varName, args.mIndex, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetBooleanMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetDoubleArrayMemberValue(self, seqid, iprot, oprot):
        args = objSetDoubleArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetDoubleArrayMemberValue_result()
        try:
            self._handler.objSetDoubleArrayMemberValue(args.varName, args.mIndex, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetDoubleArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetDoubleMemberValue(self, seqid, iprot, oprot):
        args = objSetDoubleMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetDoubleMemberValue_result()
        try:
            self._handler.objSetDoubleMemberValue(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetDoubleMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetFileExtension(self, seqid, iprot, oprot):
        args = objSetFileExtension_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetFileExtension_result()
        try:
            self._handler.objSetFileExtension(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetFileExtension", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetFileName(self, seqid, iprot, oprot):
        args = objSetFileName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetFileName_result()
        try:
            self._handler.objSetFileName(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetFileName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetIntArrayMemberValue(self, seqid, iprot, oprot):
        args = objSetIntArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetIntArrayMemberValue_result()
        try:
            self._handler.objSetIntArrayMemberValue(args.varName, args.mIndex, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetIntArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetIntMemberValue(self, seqid, iprot, oprot):
        args = objSetIntMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetIntMemberValue_result()
        try:
            self._handler.objSetIntMemberValue(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetIntMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetIsBinary(self, seqid, iprot, oprot):
        args = objSetIsBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetIsBinary_result()
        try:
            self._handler.objSetIsBinary(args.varName, args.mIndex, args.flag)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetIsBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMember(self, seqid, iprot, oprot):
        args = objSetMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMember_result()
        try:
            self._handler.objSetMember(args.varName, args.mIndex, args.value, args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMember", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberDescription(self, seqid, iprot, oprot):
        args = objSetMemberDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberDescription_result()
        try:
            self._handler.objSetMemberDescription(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberDimensions(self, seqid, iprot, oprot):
        args = objSetMemberDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberDimensions_result()
        try:
            self._handler.objSetMemberDimensions(args.varName, args.mIndex, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberEnumAliases(self, seqid, iprot, oprot):
        args = objSetMemberEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberEnumAliases_result()
        try:
            self._handler.objSetMemberEnumAliases(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberEnumValues(self, seqid, iprot, oprot):
        args = objSetMemberEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberEnumValues_result()
        try:
            self._handler.objSetMemberEnumValues(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberLength(self, seqid, iprot, oprot):
        args = objSetMemberLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberLength_result()
        try:
            self._handler.objSetMemberLength(args.varName, args.mIndex, args.length, args.dim)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberLowerBound(self, seqid, iprot, oprot):
        args = objSetMemberLowerBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberLowerBound_result()
        try:
            self._handler.objSetMemberLowerBound(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberLowerBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberProperty(self, seqid, iprot, oprot):
        args = objSetMemberProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberProperty_result()
        try:
            self._handler.objSetMemberProperty(args.varName, args.mIndex, args.propertyName, args.propertyValue)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberUnits(self, seqid, iprot, oprot):
        args = objSetMemberUnits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberUnits_result()
        try:
            self._handler.objSetMemberUnits(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberUnits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberUpperBound(self, seqid, iprot, oprot):
        args = objSetMemberUpperBound_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberUpperBound_result()
        try:
            self._handler.objSetMemberUpperBound(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberUpperBound", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetMemberValueFromString(self, seqid, iprot, oprot):
        args = objSetMemberValueFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetMemberValueFromString_result()
        try:
            self._handler.objSetMemberValueFromString(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetMemberValueFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetStringArrayMemberValue(self, seqid, iprot, oprot):
        args = objSetStringArrayMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetStringArrayMemberValue_result()
        try:
            self._handler.objSetStringArrayMemberValue(args.varName, args.mIndex, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetStringArrayMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objSetStringMemberValue(self, seqid, iprot, oprot):
        args = objSetStringMemberValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objSetStringMemberValue_result()
        try:
            self._handler.objSetStringMemberValue(args.varName, args.mIndex, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objSetStringMemberValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objToFile(self, seqid, iprot, oprot):
        args = objToFile_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objToFile_result()
        try:
            self._handler.objToFile(args.varName, args.mIndex, args.fileName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objToFile", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objToString(self, seqid, iprot, oprot):
        args = objToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objToString_result()
        try:
            result.success = self._handler.objToString(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_objToXML(self, seqid, iprot, oprot):
        args = objToXML_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = objToXML_result()
        try:
            result.success = self._handler.objToXML(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("objToXML", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperAddMethod(self, seqid, iprot, oprot):
        args = wrapperAddMethod_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperAddMethod_result()
        try:
            self._handler.wrapperAddMethod(args.methodName, args.fullName, args.downloadInputs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperAddMethod", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperAddVariable(self, seqid, iprot, oprot):
        args = wrapperAddVariable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperAddVariable_result()
        try:
            self._handler.wrapperAddVariable(args.varName, args.varType, args.isInput)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperAddVariable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperGetDictKey(self, seqid, iprot, oprot):
        args = wrapperGetDictKey_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperGetDictKey_result()
        try:
            result.success = self._handler.wrapperGetDictKey(args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperGetDictKey", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperGetDictNumEntries(self, seqid, iprot, oprot):
        args = wrapperGetDictNumEntries_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperGetDictNumEntries_result()
        try:
            result.success = self._handler.wrapperGetDictNumEntries()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperGetDictNumEntries", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperGetDictValue(self, seqid, iprot, oprot):
        args = wrapperGetDictValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperGetDictValue_result()
        try:
            result.success = self._handler.wrapperGetDictValue(args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperGetDictValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperGetDirectory(self, seqid, iprot, oprot):
        args = wrapperGetDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperGetDirectory_result()
        try:
            result.success = self._handler.wrapperGetDirectory()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperGetDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperGetRunDirectory(self, seqid, iprot, oprot):
        args = wrapperGetRunDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperGetRunDirectory_result()
        try:
            result.success = self._handler.wrapperGetRunDirectory()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperGetRunDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperGetVarType(self, seqid, iprot, oprot):
        args = wrapperGetVarType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperGetVarType_result()
        try:
            result.success = self._handler.wrapperGetVarType(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperGetVarType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperRemoveVariable(self, seqid, iprot, oprot):
        args = wrapperRemoveVariable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperRemoveVariable_result()
        try:
            self._handler.wrapperRemoveVariable(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperRemoveVariable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wrapperSleep(self, seqid, iprot, oprot):
        args = wrapperSleep_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wrapperSleep_result()
        try:
            self._handler.wrapperSleep(args.milliSeconds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wrapperSleep", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayFromString(self, seqid, iprot, oprot):
        args = arrayFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayFromString_result()
        try:
            self._handler.arrayFromString(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayGetDimensions(self, seqid, iprot, oprot):
        args = arrayGetDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayGetDimensions_result()
        try:
            result.success = self._handler.arrayGetDimensions(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayGetDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayGetLength(self, seqid, iprot, oprot):
        args = arrayGetLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayGetLength_result()
        try:
            result.success = self._handler.arrayGetLength(args.varName, args.dim)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayGetLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayGetLockResize(self, seqid, iprot, oprot):
        args = arrayGetLockResize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayGetLockResize_result()
        try:
            result.success = self._handler.arrayGetLockResize(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayGetLockResize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayGetNumDimensions(self, seqid, iprot, oprot):
        args = arrayGetNumDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayGetNumDimensions_result()
        try:
            result.success = self._handler.arrayGetNumDimensions(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayGetNumDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayLockDimensions(self, seqid, iprot, oprot):
        args = arrayLockDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayLockDimensions_result()
        try:
            self._handler.arrayLockDimensions(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayLockDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arraySetDimensions(self, seqid, iprot, oprot):
        args = arraySetDimensions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arraySetDimensions_result()
        try:
            self._handler.arraySetDimensions(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arraySetDimensions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arraySetLength(self, seqid, iprot, oprot):
        args = arraySetLength_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arraySetLength_result()
        try:
            self._handler.arraySetLength(args.varName, args.length, args.dim)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arraySetLength", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arraySetLockResize(self, seqid, iprot, oprot):
        args = arraySetLockResize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arraySetLockResize_result()
        try:
            self._handler.arraySetLockResize(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arraySetLockResize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_arrayToString(self, seqid, iprot, oprot):
        args = arrayToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = arrayToString_result()
        try:
            result.success = self._handler.arrayToString(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("arrayToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simpleGetDescription(self, seqid, iprot, oprot):
        args = simpleGetDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simpleGetDescription_result()
        try:
            result.success = self._handler.simpleGetDescription(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simpleGetDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simpleGetHasChanged(self, seqid, iprot, oprot):
        args = simpleGetHasChanged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simpleGetHasChanged_result()
        try:
            result.success = self._handler.simpleGetHasChanged(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simpleGetHasChanged", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simpleGetUnits(self, seqid, iprot, oprot):
        args = simpleGetUnits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simpleGetUnits_result()
        try:
            result.success = self._handler.simpleGetUnits(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simpleGetUnits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simpleSetDescription(self, seqid, iprot, oprot):
        args = simpleSetDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simpleSetDescription_result()
        try:
            self._handler.simpleSetDescription(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simpleSetDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simpleSetHasChanged(self, seqid, iprot, oprot):
        args = simpleSetHasChanged_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simpleSetHasChanged_result()
        try:
            self._handler.simpleSetHasChanged(args.varName, args.boolVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simpleSetHasChanged", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simpleSetUnits(self, seqid, iprot, oprot):
        args = simpleSetUnits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simpleSetUnits_result()
        try:
            self._handler.simpleSetUnits(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simpleSetUnits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strGetEnumAliases(self, seqid, iprot, oprot):
        args = strGetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strGetEnumAliases_result()
        try:
            result.success = self._handler.strGetEnumAliases(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strGetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strGetEnumValues(self, seqid, iprot, oprot):
        args = strGetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strGetEnumValues_result()
        try:
            result.success = self._handler.strGetEnumValues(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strGetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strGetValue(self, seqid, iprot, oprot):
        args = strGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strGetValue_result()
        try:
            result.success = self._handler.strGetValue(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strSetEnumAliases(self, seqid, iprot, oprot):
        args = strSetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strSetEnumAliases_result()
        try:
            self._handler.strSetEnumAliases(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strSetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strSetEnumValues(self, seqid, iprot, oprot):
        args = strSetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strSetEnumValues_result()
        try:
            self._handler.strSetEnumValues(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strSetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strSetValue(self, seqid, iprot, oprot):
        args = strSetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strSetValue_result()
        try:
            self._handler.strSetValue(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strSetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArrayFromString(self, seqid, iprot, oprot):
        args = strArrayFromString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArrayFromString_result()
        try:
            self._handler.strArrayFromString(args.varName, args.index, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArrayFromString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArrayGetEnumAliases(self, seqid, iprot, oprot):
        args = strArrayGetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArrayGetEnumAliases_result()
        try:
            result.success = self._handler.strArrayGetEnumAliases(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArrayGetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArrayGetEnumValues(self, seqid, iprot, oprot):
        args = strArrayGetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArrayGetEnumValues_result()
        try:
            result.success = self._handler.strArrayGetEnumValues(args.varName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArrayGetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArrayGetValue(self, seqid, iprot, oprot):
        args = strArrayGetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArrayGetValue_result()
        try:
            result.success = self._handler.strArrayGetValue(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArrayGetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArraySetEnumAliases(self, seqid, iprot, oprot):
        args = strArraySetEnumAliases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArraySetEnumAliases_result()
        try:
            self._handler.strArraySetEnumAliases(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArraySetEnumAliases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArraySetEnumValues(self, seqid, iprot, oprot):
        args = strArraySetEnumValues_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArraySetEnumValues_result()
        try:
            self._handler.strArraySetEnumValues(args.varName, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArraySetEnumValues", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArraySetValue(self, seqid, iprot, oprot):
        args = strArraySetValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArraySetValue_result()
        try:
            self._handler.strArraySetValue(args.varName, args.index, args.strVal)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArraySetValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_strArrayToString(self, seqid, iprot, oprot):
        args = strArrayToString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = strArrayToString_result()
        try:
            result.success = self._handler.strArrayToString(args.varName, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except GeneralError as generalError:
            msg_type = TMessageType.REPLY
            result.generalError = generalError
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("strArrayToString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class init_args(object):
    """
    Attributes:
     - epoch: Python Epoch, to ensure bidirectional communication.

    """


    def __init__(self, epoch=None,):
        self.epoch = epoch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.epoch = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_args')
        if self.epoch is not None:
            oprot.writeFieldBegin('epoch', TType.STRING, 1)
            oprot.writeString(self.epoch.encode('utf-8') if sys.version_info[0] == 2 else self.epoch)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_args)
init_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'epoch', 'UTF8', None, ),  # 1
)


class init_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ScriptWrapperInitialization()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_result)
init_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ScriptWrapperInitialization, None], None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class initSuccess_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initSuccess_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initSuccess_args)
initSuccess_args.thrift_spec = (
)


class initSuccess_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initSuccess_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initSuccess_result)
initSuccess_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class initFailed_args(object):
    """
    Attributes:
     - error: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.  Typically
    such messages include (but only message is required):
       * Error message
       * Stack trace of script files and line numbers.

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.error = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initFailed_args')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRING, 1)
            oprot.writeString(self.error.encode('utf-8') if sys.version_info[0] == 2 else self.error)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initFailed_args)
initFailed_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'error', 'UTF8', None, ),  # 1
)


class initFailed_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initFailed_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initFailed_result)
initFailed_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class GetNewRun_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNewRun_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNewRun_args)
GetNewRun_args.thrift_spec = (
)


class GetNewRun_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetNewRun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetNewRun_result)
GetNewRun_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class Success_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Success_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Success_args)
Success_args.thrift_spec = (
)


class Success_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Success_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Success_result)
Success_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class Failed_args(object):
    """
    Attributes:
     - error: A descriptive message that will be displayed to the user and logged.  Such may contain new lines.  Typically
    such messages include (but only message is required):
       * Error message
       * Stack trace of script files and line numbers.

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.error = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Failed_args')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRING, 1)
            oprot.writeString(self.error.encode('utf-8') if sys.version_info[0] == 2 else self.error)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Failed_args)
Failed_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'error', 'UTF8', None, ),  # 1
)


class Failed_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Failed_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Failed_result)
Failed_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolGetValue_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolGetValue_args)
boolGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class boolGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolGetValue_result)
boolGetValue_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolSetValue_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolSetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolSetValue_args)
boolSetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class boolSetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolSetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolSetValue_result)
boolSetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolToString_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolToString_args)
boolToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class boolToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolToString_result)
boolToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolArrayFromString_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayFromString_args)
boolArrayFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class boolArrayFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayFromString_result)
boolArrayFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolArrayGetValue_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayGetValue_args)
boolArrayGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class boolArrayGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayGetValue_result)
boolArrayGetValue_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolArrayGetValueStr_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayGetValueStr_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayGetValueStr_args)
boolArrayGetValueStr_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class boolArrayGetValueStr_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayGetValueStr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayGetValueStr_result)
boolArrayGetValueStr_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolArraySetValue_args(object):
    """
    Attributes:
     - varName
     - index
     - boolVal

    """


    def __init__(self, varName=None, index=None, boolVal=None,):
        self.varName = varName
        self.index = index
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArraySetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 3)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArraySetValue_args)
boolArraySetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'boolVal', None, None, ),  # 3
)


class boolArraySetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArraySetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArraySetValue_result)
boolArraySetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class boolArrayToString_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayToString_args)
boolArrayToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class boolArrayToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('boolArrayToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(boolArrayToString_result)
boolArrayToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblFromString_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblFromString_args)
dblFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblFromString_result)
dblFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetEnumAliases_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetEnumAliases_args)
dblGetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetEnumAliases_result)
dblGetEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetEnumValues_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetEnumValues_args)
dblGetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetEnumValues_result)
dblGetEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetFormat_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetFormat_args)
dblGetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetFormat_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetFormat_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetFormat_result)
dblGetFormat_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetHasLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetHasLowerBound_args)
dblGetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetHasLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetHasLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetHasLowerBound_result)
dblGetHasLowerBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetHasUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetHasUpperBound_args)
dblGetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetHasUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetHasUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetHasUpperBound_result)
dblGetHasUpperBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetLowerBound_args)
dblGetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetLowerBound_result)
dblGetLowerBound_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetUpperBound_args)
dblGetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetUpperBound_result)
dblGetUpperBound_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblGetValue_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetValue_args)
dblGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblGetValue_result)
dblGetValue_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetEnumAliases_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetEnumAliases_args)
dblSetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblSetEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetEnumAliases_result)
dblSetEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetEnumValues_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetEnumValues_args)
dblSetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblSetEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetEnumValues_result)
dblSetEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetFormat_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetFormat_args)
dblSetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblSetFormat_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetFormat_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetFormat_result)
dblSetFormat_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetHasLowerBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetHasLowerBound_args)
dblSetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class dblSetHasLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetHasLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetHasLowerBound_result)
dblSetHasLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetHasUpperBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetHasUpperBound_args)
dblSetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class dblSetHasUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetHasUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetHasUpperBound_result)
dblSetHasUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetLowerBound_args(object):
    """
    Attributes:
     - varName
     - dblVal

    """


    def __init__(self, varName=None, dblVal=None,):
        self.varName = varName
        self.dblVal = dblVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.dblVal = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.dblVal is not None:
            oprot.writeFieldBegin('dblVal', TType.DOUBLE, 2)
            oprot.writeDouble(self.dblVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetLowerBound_args)
dblSetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'dblVal', None, None, ),  # 2
)


class dblSetLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetLowerBound_result)
dblSetLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetUpperBound_args(object):
    """
    Attributes:
     - varName
     - dblVal

    """


    def __init__(self, varName=None, dblVal=None,):
        self.varName = varName
        self.dblVal = dblVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.dblVal = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.dblVal is not None:
            oprot.writeFieldBegin('dblVal', TType.DOUBLE, 2)
            oprot.writeDouble(self.dblVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetUpperBound_args)
dblSetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'dblVal', None, None, ),  # 2
)


class dblSetUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetUpperBound_result)
dblSetUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblSetValue_args(object):
    """
    Attributes:
     - varName
     - dblVal

    """


    def __init__(self, varName=None, dblVal=None,):
        self.varName = varName
        self.dblVal = dblVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.dblVal = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.dblVal is not None:
            oprot.writeFieldBegin('dblVal', TType.DOUBLE, 2)
            oprot.writeDouble(self.dblVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetValue_args)
dblSetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'dblVal', None, None, ),  # 2
)


class dblSetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblSetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblSetValue_result)
dblSetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblToString_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblToString_args)
dblToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblToString_result)
dblToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayFromString_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayFromString_args)
dblArrayFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class dblArrayFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayFromString_result)
dblArrayFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetEnumAliases_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetEnumAliases_args)
dblArrayGetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetEnumAliases_result)
dblArrayGetEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetEnumValues_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetEnumValues_args)
dblArrayGetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetEnumValues_result)
dblArrayGetEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetFormat_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetFormat_args)
dblArrayGetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetFormat_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetFormat_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetFormat_result)
dblArrayGetFormat_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetHasLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetHasLowerBound_args)
dblArrayGetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetHasLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetHasLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetHasLowerBound_result)
dblArrayGetHasLowerBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetHasUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetHasUpperBound_args)
dblArrayGetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetHasUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetHasUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetHasUpperBound_result)
dblArrayGetHasUpperBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetLowerBound_args)
dblArrayGetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetLowerBound_result)
dblArrayGetLowerBound_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetUpperBound_args)
dblArrayGetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class dblArrayGetUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetUpperBound_result)
dblArrayGetUpperBound_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayGetValue_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetValue_args)
dblArrayGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class dblArrayGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayGetValue_result)
dblArrayGetValue_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetEnumAliases_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetEnumAliases_args)
dblArraySetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblArraySetEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetEnumAliases_result)
dblArraySetEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetEnumValues_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetEnumValues_args)
dblArraySetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblArraySetEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetEnumValues_result)
dblArraySetEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetFormat_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetFormat_args)
dblArraySetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class dblArraySetFormat_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetFormat_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetFormat_result)
dblArraySetFormat_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetHasLowerBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetHasLowerBound_args)
dblArraySetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class dblArraySetHasLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetHasLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetHasLowerBound_result)
dblArraySetHasLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetHasUpperBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetHasUpperBound_args)
dblArraySetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class dblArraySetHasUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetHasUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetHasUpperBound_result)
dblArraySetHasUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetLowerBound_args(object):
    """
    Attributes:
     - varName
     - dblVal

    """


    def __init__(self, varName=None, dblVal=None,):
        self.varName = varName
        self.dblVal = dblVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.dblVal = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.dblVal is not None:
            oprot.writeFieldBegin('dblVal', TType.DOUBLE, 2)
            oprot.writeDouble(self.dblVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetLowerBound_args)
dblArraySetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'dblVal', None, None, ),  # 2
)


class dblArraySetLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetLowerBound_result)
dblArraySetLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetUpperBound_args(object):
    """
    Attributes:
     - varName
     - dblVal

    """


    def __init__(self, varName=None, dblVal=None,):
        self.varName = varName
        self.dblVal = dblVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.dblVal = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.dblVal is not None:
            oprot.writeFieldBegin('dblVal', TType.DOUBLE, 2)
            oprot.writeDouble(self.dblVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetUpperBound_args)
dblArraySetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'dblVal', None, None, ),  # 2
)


class dblArraySetUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetUpperBound_result)
dblArraySetUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArraySetValue_args(object):
    """
    Attributes:
     - varName
     - index
     - dblVal

    """


    def __init__(self, varName=None, index=None, dblVal=None,):
        self.varName = varName
        self.index = index
        self.dblVal = dblVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.dblVal = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.dblVal is not None:
            oprot.writeFieldBegin('dblVal', TType.DOUBLE, 3)
            oprot.writeDouble(self.dblVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetValue_args)
dblArraySetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'dblVal', None, None, ),  # 3
)


class dblArraySetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArraySetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArraySetValue_result)
dblArraySetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class dblArrayToString_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayToString_args)
dblArrayToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class dblArrayToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dblArrayToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dblArrayToString_result)
dblArrayToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longFromString_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longFromString_args)
longFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longFromString_result)
longFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetEnumAliases_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetEnumAliases_args)
longGetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetEnumAliases_result)
longGetEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetEnumValues_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetEnumValues_args)
longGetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetEnumValues_result)
longGetEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetFormat_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetFormat_args)
longGetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetFormat_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetFormat_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetFormat_result)
longGetFormat_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetHasLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetHasLowerBound_args)
longGetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetHasLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetHasLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetHasLowerBound_result)
longGetHasLowerBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetHasUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetHasUpperBound_args)
longGetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetHasUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetHasUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetHasUpperBound_result)
longGetHasUpperBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetLowerBound_args)
longGetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetLowerBound_result)
longGetLowerBound_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetUpperBound_args)
longGetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetUpperBound_result)
longGetUpperBound_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longGetValue_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetValue_args)
longGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longGetValue_result)
longGetValue_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetEnumAliases_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetEnumAliases_args)
longSetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longSetEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetEnumAliases_result)
longSetEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetEnumValues_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetEnumValues_args)
longSetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longSetEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetEnumValues_result)
longSetEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetFormat_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetFormat_args)
longSetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longSetFormat_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetFormat_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetFormat_result)
longSetFormat_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetHasLowerBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetHasLowerBound_args)
longSetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class longSetHasLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetHasLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetHasLowerBound_result)
longSetHasLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetHasUpperBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetHasUpperBound_args)
longSetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class longSetHasUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetHasUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetHasUpperBound_result)
longSetHasUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetLowerBound_args(object):
    """
    Attributes:
     - varName
     - value

    """


    def __init__(self, varName=None, value=None,):
        self.varName = varName
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 2)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetLowerBound_args)
longSetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'value', None, None, ),  # 2
)


class longSetLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetLowerBound_result)
longSetLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetUpperBound_args(object):
    """
    Attributes:
     - varName
     - value

    """


    def __init__(self, varName=None, value=None,):
        self.varName = varName
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 2)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetUpperBound_args)
longSetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'value', None, None, ),  # 2
)


class longSetUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetUpperBound_result)
longSetUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longSetValue_args(object):
    """
    Attributes:
     - varName
     - value

    """


    def __init__(self, varName=None, value=None,):
        self.varName = varName
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 2)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetValue_args)
longSetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'value', None, None, ),  # 2
)


class longSetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longSetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longSetValue_result)
longSetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longToString_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longToString_args)
longToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longToString_result)
longToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayFromString_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayFromString_args)
longArrayFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class longArrayFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayFromString_result)
longArrayFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetEnumAliases_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetEnumAliases_args)
longArrayGetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetEnumAliases_result)
longArrayGetEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetEnumValues_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetEnumValues_args)
longArrayGetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetEnumValues_result)
longArrayGetEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetFormat_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetFormat_args)
longArrayGetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetFormat_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetFormat_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetFormat_result)
longArrayGetFormat_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetHasLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetHasLowerBound_args)
longArrayGetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetHasLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetHasLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetHasLowerBound_result)
longArrayGetHasLowerBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetHasUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetHasUpperBound_args)
longArrayGetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetHasUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetHasUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetHasUpperBound_result)
longArrayGetHasUpperBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetLowerBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetLowerBound_args)
longArrayGetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetLowerBound_result)
longArrayGetLowerBound_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetUpperBound_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetUpperBound_args)
longArrayGetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class longArrayGetUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetUpperBound_result)
longArrayGetUpperBound_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayGetValue_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetValue_args)
longArrayGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class longArrayGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayGetValue_result)
longArrayGetValue_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetEnumAliases_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetEnumAliases_args)
longArraySetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longArraySetEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetEnumAliases_result)
longArraySetEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetEnumValues_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetEnumValues_args)
longArraySetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longArraySetEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetEnumValues_result)
longArraySetEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetFormat_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetFormat_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetFormat_args)
longArraySetFormat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class longArraySetFormat_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetFormat_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetFormat_result)
longArraySetFormat_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetHasLowerBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetHasLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetHasLowerBound_args)
longArraySetHasLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class longArraySetHasLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetHasLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetHasLowerBound_result)
longArraySetHasLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetHasUpperBound_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetHasUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetHasUpperBound_args)
longArraySetHasUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class longArraySetHasUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetHasUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetHasUpperBound_result)
longArraySetHasUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetLowerBound_args(object):
    """
    Attributes:
     - varName
     - value

    """


    def __init__(self, varName=None, value=None,):
        self.varName = varName
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 2)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetLowerBound_args)
longArraySetLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'value', None, None, ),  # 2
)


class longArraySetLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetLowerBound_result)
longArraySetLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetUpperBound_args(object):
    """
    Attributes:
     - varName
     - value

    """


    def __init__(self, varName=None, value=None,):
        self.varName = varName
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 2)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetUpperBound_args)
longArraySetUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'value', None, None, ),  # 2
)


class longArraySetUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetUpperBound_result)
longArraySetUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArraySetValue_args(object):
    """
    Attributes:
     - varName
     - index
     - value

    """


    def __init__(self, varName=None, index=None, value=None,):
        self.varName = varName
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 3)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetValue_args)
longArraySetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.I64, 'value', None, None, ),  # 3
)


class longArraySetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArraySetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArraySetValue_result)
longArraySetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class longArrayToString_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayToString_args)
longArrayToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class longArrayToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('longArrayToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(longArrayToString_result)
longArrayToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileFromFile_args(object):
    """
    Attributes:
     - varName
     - fileName

    """


    def __init__(self, varName=None, fileName=None,):
        self.varName = varName
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileFromFile_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 2)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileFromFile_args)
fileFromFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'fileName', 'UTF8', None, ),  # 2
)


class fileFromFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileFromFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileFromFile_result)
fileFromFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileFromString_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileFromString_args)
fileFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class fileFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileFromString_result)
fileFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetBaseName_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetBaseName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetBaseName_args)
fileGetBaseName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetBaseName_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetBaseName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetBaseName_result)
fileGetBaseName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetContents_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetContents_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetContents_args)
fileGetContents_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetContents_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetContents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetContents_result)
fileGetContents_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetFileExtension_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetFileExtension_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetFileExtension_args)
fileGetFileExtension_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetFileExtension_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetFileExtension_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetFileExtension_result)
fileGetFileExtension_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetIsBinary_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetIsBinary_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetIsBinary_args)
fileGetIsBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetIsBinary_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetIsBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetIsBinary_result)
fileGetIsBinary_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetMimeType_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetMimeType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetMimeType_args)
fileGetMimeType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetMimeType_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetMimeType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetMimeType_result)
fileGetMimeType_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetName_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetName_args)
fileGetName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetName_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetName_result)
fileGetName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileGetNameCoded_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetNameCoded_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetNameCoded_args)
fileGetNameCoded_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileGetNameCoded_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileGetNameCoded_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileGetNameCoded_result)
fileGetNameCoded_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileHasChanged_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileHasChanged_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileHasChanged_args)
fileHasChanged_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileHasChanged_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileHasChanged_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileHasChanged_result)
fileHasChanged_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileMarkAsRead_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileMarkAsRead_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileMarkAsRead_args)
fileMarkAsRead_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileMarkAsRead_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileMarkAsRead_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileMarkAsRead_result)
fileMarkAsRead_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileSetBaseName_args(object):
    """
    Attributes:
     - varName
     - name

    """


    def __init__(self, varName=None, name=None,):
        self.varName = varName
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetBaseName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetBaseName_args)
fileSetBaseName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)


class fileSetBaseName_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetBaseName_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetBaseName_result)
fileSetBaseName_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileSetContents_args(object):
    """
    Attributes:
     - varName
     - contents

    """


    def __init__(self, varName=None, contents=None,):
        self.varName = varName
        self.contents = contents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.contents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetContents_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRING, 2)
            oprot.writeString(self.contents.encode('utf-8') if sys.version_info[0] == 2 else self.contents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetContents_args)
fileSetContents_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'contents', 'UTF8', None, ),  # 2
)


class fileSetContents_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetContents_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetContents_result)
fileSetContents_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileSetFileExtension_args(object):
    """
    Attributes:
     - varName
     - extension

    """


    def __init__(self, varName=None, extension=None,):
        self.varName = varName
        self.extension = extension

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.extension = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetFileExtension_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.extension is not None:
            oprot.writeFieldBegin('extension', TType.STRING, 2)
            oprot.writeString(self.extension.encode('utf-8') if sys.version_info[0] == 2 else self.extension)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetFileExtension_args)
fileSetFileExtension_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'extension', 'UTF8', None, ),  # 2
)


class fileSetFileExtension_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetFileExtension_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetFileExtension_result)
fileSetFileExtension_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileSetIsBinary_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetIsBinary_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetIsBinary_args)
fileSetIsBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class fileSetIsBinary_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetIsBinary_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetIsBinary_result)
fileSetIsBinary_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileSetMimeType_args(object):
    """
    Attributes:
     - varName
     - mimeType

    """


    def __init__(self, varName=None, mimeType=None,):
        self.varName = varName
        self.mimeType = mimeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mimeType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetMimeType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mimeType is not None:
            oprot.writeFieldBegin('mimeType', TType.STRING, 2)
            oprot.writeString(self.mimeType.encode('utf-8') if sys.version_info[0] == 2 else self.mimeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetMimeType_args)
fileSetMimeType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mimeType', 'UTF8', None, ),  # 2
)


class fileSetMimeType_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetMimeType_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetMimeType_result)
fileSetMimeType_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileSetName_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetName_args)
fileSetName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class fileSetName_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileSetName_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileSetName_result)
fileSetName_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileToFile_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileToFile_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileToFile_args)
fileToFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class fileToFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileToFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileToFile_result)
fileToFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileToString_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileToString_args)
fileToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileToString_result)
fileToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayFromFile_args(object):
    """
    Attributes:
     - varName
     - index
     - fileName

    """


    def __init__(self, varName=None, index=None, fileName=None,):
        self.varName = varName
        self.index = index
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayFromFile_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 3)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayFromFile_args)
fileArrayFromFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'fileName', 'UTF8', None, ),  # 3
)


class fileArrayFromFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayFromFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayFromFile_result)
fileArrayFromFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayFromString_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayFromString_args)
fileArrayFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class fileArrayFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayFromString_result)
fileArrayFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetBaseName_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetBaseName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetBaseName_args)
fileArrayGetBaseName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileArrayGetBaseName_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetBaseName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetBaseName_result)
fileArrayGetBaseName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetContents_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetContents_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetContents_args)
fileArrayGetContents_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayGetContents_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetContents_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetContents_result)
fileArrayGetContents_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetFileExtension_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetFileExtension_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetFileExtension_args)
fileArrayGetFileExtension_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayGetFileExtension_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetFileExtension_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetFileExtension_result)
fileArrayGetFileExtension_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetIsBinary_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetIsBinary_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetIsBinary_args)
fileArrayGetIsBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileArrayGetIsBinary_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetIsBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetIsBinary_result)
fileArrayGetIsBinary_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetMimeType_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetMimeType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetMimeType_args)
fileArrayGetMimeType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class fileArrayGetMimeType_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetMimeType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetMimeType_result)
fileArrayGetMimeType_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetName_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetName_args)
fileArrayGetName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayGetName_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetName_result)
fileArrayGetName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayGetNameCoded_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetNameCoded_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetNameCoded_args)
fileArrayGetNameCoded_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayGetNameCoded_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayGetNameCoded_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayGetNameCoded_result)
fileArrayGetNameCoded_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayHasChanged_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayHasChanged_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayHasChanged_args)
fileArrayHasChanged_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayHasChanged_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayHasChanged_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayHasChanged_result)
fileArrayHasChanged_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayMarkAsRead_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayMarkAsRead_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayMarkAsRead_args)
fileArrayMarkAsRead_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayMarkAsRead_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayMarkAsRead_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayMarkAsRead_result)
fileArrayMarkAsRead_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArraySetBaseName_args(object):
    """
    Attributes:
     - varName
     - name

    """


    def __init__(self, varName=None, name=None,):
        self.varName = varName
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetBaseName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetBaseName_args)
fileArraySetBaseName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
)


class fileArraySetBaseName_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetBaseName_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetBaseName_result)
fileArraySetBaseName_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArraySetContents_args(object):
    """
    Attributes:
     - varName
     - index
     - contents

    """


    def __init__(self, varName=None, index=None, contents=None,):
        self.varName = varName
        self.index = index
        self.contents = contents

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.contents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetContents_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRING, 3)
            oprot.writeString(self.contents.encode('utf-8') if sys.version_info[0] == 2 else self.contents)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetContents_args)
fileArraySetContents_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'contents', 'UTF8', None, ),  # 3
)


class fileArraySetContents_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetContents_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetContents_result)
fileArraySetContents_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArraySetFileExtension_args(object):
    """
    Attributes:
     - varName
     - index
     - extension

    """


    def __init__(self, varName=None, index=None, extension=None,):
        self.varName = varName
        self.index = index
        self.extension = extension

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.extension = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetFileExtension_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.extension is not None:
            oprot.writeFieldBegin('extension', TType.STRING, 3)
            oprot.writeString(self.extension.encode('utf-8') if sys.version_info[0] == 2 else self.extension)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetFileExtension_args)
fileArraySetFileExtension_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'extension', 'UTF8', None, ),  # 3
)


class fileArraySetFileExtension_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetFileExtension_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetFileExtension_result)
fileArraySetFileExtension_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArraySetIsBinary_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetIsBinary_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetIsBinary_args)
fileArraySetIsBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class fileArraySetIsBinary_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetIsBinary_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetIsBinary_result)
fileArraySetIsBinary_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArraySetMimeType_args(object):
    """
    Attributes:
     - varName
     - mimeType

    """


    def __init__(self, varName=None, mimeType=None,):
        self.varName = varName
        self.mimeType = mimeType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mimeType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetMimeType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mimeType is not None:
            oprot.writeFieldBegin('mimeType', TType.STRING, 2)
            oprot.writeString(self.mimeType.encode('utf-8') if sys.version_info[0] == 2 else self.mimeType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetMimeType_args)
fileArraySetMimeType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mimeType', 'UTF8', None, ),  # 2
)


class fileArraySetMimeType_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetMimeType_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetMimeType_result)
fileArraySetMimeType_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArraySetName_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetName_args)
fileArraySetName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class fileArraySetName_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArraySetName_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArraySetName_result)
fileArraySetName_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayToFile_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayToFile_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayToFile_args)
fileArrayToFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class fileArrayToFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayToFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayToFile_result)
fileArrayToFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class fileArrayToString_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayToString_args)
fileArrayToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class fileArrayToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fileArrayToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fileArrayToString_result)
fileArrayToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class newPHXRowFieldFile_args(object):
    """
    Attributes:
     - mode

    """


    def __init__(self, mode=None,):
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('newPHXRowFieldFile_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(newPHXRowFieldFile_args)
newPHXRowFieldFile_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
)


class newPHXRowFieldFile_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('newPHXRowFieldFile_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(newPHXRowFieldFile_result)
newPHXRowFieldFile_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffClearMarks_args(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffClearMarks_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffClearMarks_args)
rffClearMarks_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
)


class rffClearMarks_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffClearMarks_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffClearMarks_result)
rffClearMarks_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffClose_args(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffClose_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffClose_args)
rffClose_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
)


class rffClose_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffClose_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffClose_result)
rffClose_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffDelete_args(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffDelete_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffDelete_args)
rffDelete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
)


class rffDelete_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffDelete_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffDelete_result)
rffDelete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffGenerate_args(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffGenerate_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffGenerate_args)
rffGenerate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
)


class rffGenerate_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffGenerate_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffGenerate_result)
rffGenerate_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffMarkAsBeginning_args(object):
    """
    Attributes:
     - key
     - find
     - occurrence
     - offset
     - regex

    """


    def __init__(self, key=None, find=None, occurrence=None, offset=None, regex=None,):
        self.key = key
        self.find = find
        self.occurrence = occurrence
        self.offset = offset
        self.regex = regex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.find = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.occurrence = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.regex = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffMarkAsBeginning_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.find is not None:
            oprot.writeFieldBegin('find', TType.STRING, 2)
            oprot.writeString(self.find.encode('utf-8') if sys.version_info[0] == 2 else self.find)
            oprot.writeFieldEnd()
        if self.occurrence is not None:
            oprot.writeFieldBegin('occurrence', TType.I32, 3)
            oprot.writeI32(self.occurrence)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 4)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.regex is not None:
            oprot.writeFieldBegin('regex', TType.BOOL, 5)
            oprot.writeBool(self.regex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffMarkAsBeginning_args)
rffMarkAsBeginning_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'find', 'UTF8', None, ),  # 2
    (3, TType.I32, 'occurrence', None, None, ),  # 3
    (4, TType.I32, 'offset', None, None, ),  # 4
    (5, TType.BOOL, 'regex', None, None, ),  # 5
)


class rffMarkAsBeginning_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffMarkAsBeginning_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffMarkAsBeginning_result)
rffMarkAsBeginning_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffMarkAsEnd_args(object):
    """
    Attributes:
     - key
     - find
     - occurrence
     - offset
     - regex

    """


    def __init__(self, key=None, find=None, occurrence=None, offset=None, regex=None,):
        self.key = key
        self.find = find
        self.occurrence = occurrence
        self.offset = offset
        self.regex = regex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.find = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.occurrence = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.regex = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffMarkAsEnd_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.find is not None:
            oprot.writeFieldBegin('find', TType.STRING, 2)
            oprot.writeString(self.find.encode('utf-8') if sys.version_info[0] == 2 else self.find)
            oprot.writeFieldEnd()
        if self.occurrence is not None:
            oprot.writeFieldBegin('occurrence', TType.I32, 3)
            oprot.writeI32(self.occurrence)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 4)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.regex is not None:
            oprot.writeFieldBegin('regex', TType.BOOL, 5)
            oprot.writeBool(self.regex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffMarkAsEnd_args)
rffMarkAsEnd_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'find', 'UTF8', None, ),  # 2
    (3, TType.I32, 'occurrence', None, None, ),  # 3
    (4, TType.I32, 'offset', None, None, ),  # 4
    (5, TType.BOOL, 'regex', None, None, ),  # 5
)


class rffMarkAsEnd_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffMarkAsEnd_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffMarkAsEnd_result)
rffMarkAsEnd_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffReadDouble_args(object):
    """
    Attributes:
     - key
     - row
     - field

    """


    def __init__(self, key=None, row=None, field=None,):
        self.key = key
        self.row = row
        self.field = field

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.row = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.field = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffReadDouble_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.I32, 2)
            oprot.writeI32(self.row)
            oprot.writeFieldEnd()
        if self.field is not None:
            oprot.writeFieldBegin('field', TType.I32, 3)
            oprot.writeI32(self.field)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffReadDouble_args)
rffReadDouble_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'row', None, None, ),  # 2
    (3, TType.I32, 'field', None, None, ),  # 3
)


class rffReadDouble_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffReadDouble_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffReadDouble_result)
rffReadDouble_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffReadLong_args(object):
    """
    Attributes:
     - key
     - row
     - field

    """


    def __init__(self, key=None, row=None, field=None,):
        self.key = key
        self.row = row
        self.field = field

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.row = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.field = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffReadLong_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.I32, 2)
            oprot.writeI32(self.row)
            oprot.writeFieldEnd()
        if self.field is not None:
            oprot.writeFieldBegin('field', TType.I32, 3)
            oprot.writeI32(self.field)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffReadLong_args)
rffReadLong_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'row', None, None, ),  # 2
    (3, TType.I32, 'field', None, None, ),  # 3
)


class rffReadLong_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffReadLong_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffReadLong_result)
rffReadLong_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffReadValue_args(object):
    """
    Attributes:
     - key
     - row
     - field

    """


    def __init__(self, key=None, row=None, field=None,):
        self.key = key
        self.row = row
        self.field = field

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.row = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.field = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffReadValue_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.I32, 2)
            oprot.writeI32(self.row)
            oprot.writeFieldEnd()
        if self.field is not None:
            oprot.writeFieldBegin('field', TType.I32, 3)
            oprot.writeI32(self.field)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffReadValue_args)
rffReadValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'row', None, None, ),  # 2
    (3, TType.I32, 'field', None, None, ),  # 3
)


class rffReadValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffReadValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffReadValue_result)
rffReadValue_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffSetDelimiters_args(object):
    """
    Attributes:
     - key
     - delimiters

    """


    def __init__(self, key=None, delimiters=None,):
        self.key = key
        self.delimiters = delimiters

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.delimiters = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffSetDelimiters_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.delimiters is not None:
            oprot.writeFieldBegin('delimiters', TType.STRING, 2)
            oprot.writeString(self.delimiters.encode('utf-8') if sys.version_info[0] == 2 else self.delimiters)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffSetDelimiters_args)
rffSetDelimiters_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'delimiters', 'UTF8', None, ),  # 2
)


class rffSetDelimiters_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffSetDelimiters_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffSetDelimiters_result)
rffSetDelimiters_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffSetFileToGenerateOrParse_args(object):
    """
    Attributes:
     - key
     - fileName

    """


    def __init__(self, key=None, fileName=None,):
        self.key = key
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffSetFileToGenerateOrParse_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 2)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffSetFileToGenerateOrParse_args)
rffSetFileToGenerateOrParse_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'fileName', 'UTF8', None, ),  # 2
)


class rffSetFileToGenerateOrParse_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffSetFileToGenerateOrParse_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffSetFileToGenerateOrParse_result)
rffSetFileToGenerateOrParse_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffSetTemplateFile_args(object):
    """
    Attributes:
     - key
     - fileName

    """


    def __init__(self, key=None, fileName=None,):
        self.key = key
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffSetTemplateFile_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 2)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffSetTemplateFile_args)
rffSetTemplateFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'fileName', 'UTF8', None, ),  # 2
)


class rffSetTemplateFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffSetTemplateFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffSetTemplateFile_result)
rffSetTemplateFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffTransferArray_args(object):
    """
    Attributes:
     - key
     - varName
     - rowstart
     - rowend
     - fieldstart
     - fieldend
     - resizable
     - format
     - numDimensions

    """


    def __init__(self, key=None, varName=None, rowstart=None, rowend=None, fieldstart=None, fieldend=None, resizable=None, format=None, numDimensions=None,):
        self.key = key
        self.varName = varName
        self.rowstart = rowstart
        self.rowend = rowend
        self.fieldstart = fieldstart
        self.fieldend = fieldend
        self.resizable = resizable
        self.format = format
        self.numDimensions = numDimensions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rowstart = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.rowend = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.fieldstart = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.fieldend = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.resizable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.numDimensions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffTransferArray_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 2)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.rowstart is not None:
            oprot.writeFieldBegin('rowstart', TType.I32, 3)
            oprot.writeI32(self.rowstart)
            oprot.writeFieldEnd()
        if self.rowend is not None:
            oprot.writeFieldBegin('rowend', TType.I32, 4)
            oprot.writeI32(self.rowend)
            oprot.writeFieldEnd()
        if self.fieldstart is not None:
            oprot.writeFieldBegin('fieldstart', TType.I32, 5)
            oprot.writeI32(self.fieldstart)
            oprot.writeFieldEnd()
        if self.fieldend is not None:
            oprot.writeFieldBegin('fieldend', TType.I32, 6)
            oprot.writeI32(self.fieldend)
            oprot.writeFieldEnd()
        if self.resizable is not None:
            oprot.writeFieldBegin('resizable', TType.BOOL, 7)
            oprot.writeBool(self.resizable)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 8)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        if self.numDimensions is not None:
            oprot.writeFieldBegin('numDimensions', TType.I32, 9)
            oprot.writeI32(self.numDimensions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffTransferArray_args)
rffTransferArray_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'varName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'rowstart', None, None, ),  # 3
    (4, TType.I32, 'rowend', None, None, ),  # 4
    (5, TType.I32, 'fieldstart', None, None, ),  # 5
    (6, TType.I32, 'fieldend', None, None, ),  # 6
    (7, TType.BOOL, 'resizable', None, None, ),  # 7
    (8, TType.STRING, 'format', 'UTF8', None, ),  # 8
    (9, TType.I32, 'numDimensions', None, None, ),  # 9
)


class rffTransferArray_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffTransferArray_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffTransferArray_result)
rffTransferArray_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffTransferKeyVar_args(object):
    """
    Attributes:
     - key
     - varName
     - searchKey
     - occurrence
     - rowOffset
     - field
     - fformat

    """


    def __init__(self, key=None, varName=None, searchKey=None, occurrence=None, rowOffset=None, field=None, fformat=None,):
        self.key = key
        self.varName = varName
        self.searchKey = searchKey
        self.occurrence = occurrence
        self.rowOffset = rowOffset
        self.field = field
        self.fformat = fformat

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.searchKey = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.occurrence = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.rowOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.field = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.fformat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffTransferKeyVar_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 2)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.searchKey is not None:
            oprot.writeFieldBegin('searchKey', TType.STRING, 3)
            oprot.writeString(self.searchKey.encode('utf-8') if sys.version_info[0] == 2 else self.searchKey)
            oprot.writeFieldEnd()
        if self.occurrence is not None:
            oprot.writeFieldBegin('occurrence', TType.I32, 4)
            oprot.writeI32(self.occurrence)
            oprot.writeFieldEnd()
        if self.rowOffset is not None:
            oprot.writeFieldBegin('rowOffset', TType.I32, 5)
            oprot.writeI32(self.rowOffset)
            oprot.writeFieldEnd()
        if self.field is not None:
            oprot.writeFieldBegin('field', TType.I32, 6)
            oprot.writeI32(self.field)
            oprot.writeFieldEnd()
        if self.fformat is not None:
            oprot.writeFieldBegin('fformat', TType.STRING, 7)
            oprot.writeString(self.fformat.encode('utf-8') if sys.version_info[0] == 2 else self.fformat)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffTransferKeyVar_args)
rffTransferKeyVar_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'varName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'searchKey', 'UTF8', None, ),  # 3
    (4, TType.I32, 'occurrence', None, None, ),  # 4
    (5, TType.I32, 'rowOffset', None, None, ),  # 5
    (6, TType.I32, 'field', None, None, ),  # 6
    (7, TType.STRING, 'fformat', 'UTF8', None, ),  # 7
)


class rffTransferKeyVar_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffTransferKeyVar_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffTransferKeyVar_result)
rffTransferKeyVar_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffTransferVar_args(object):
    """
    Attributes:
     - key
     - varName
     - row
     - field
     - format

    """


    def __init__(self, key=None, varName=None, row=None, field=None, format=None,):
        self.key = key
        self.varName = varName
        self.row = row
        self.field = field
        self.format = format

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.row = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.field = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.format = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffTransferVar_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 2)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.I32, 3)
            oprot.writeI32(self.row)
            oprot.writeFieldEnd()
        if self.field is not None:
            oprot.writeFieldBegin('field', TType.I32, 4)
            oprot.writeI32(self.field)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.STRING, 5)
            oprot.writeString(self.format.encode('utf-8') if sys.version_info[0] == 2 else self.format)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffTransferVar_args)
rffTransferVar_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'varName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'row', None, None, ),  # 3
    (4, TType.I32, 'field', None, None, ),  # 4
    (5, TType.STRING, 'format', 'UTF8', None, ),  # 5
)


class rffTransferVar_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffTransferVar_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffTransferVar_result)
rffTransferVar_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class rffWriteValue_args(object):
    """
    Attributes:
     - key
     - row
     - field
     - val

    """


    def __init__(self, key=None, row=None, field=None, val=None,):
        self.key = key
        self.row = row
        self.field = field
        self.val = val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.row = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.field = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.val = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffWriteValue_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.I32, 2)
            oprot.writeI32(self.row)
            oprot.writeFieldEnd()
        if self.field is not None:
            oprot.writeFieldBegin('field', TType.I32, 3)
            oprot.writeI32(self.field)
            oprot.writeFieldEnd()
        if self.val is not None:
            oprot.writeFieldBegin('val', TType.STRING, 4)
            oprot.writeString(self.val.encode('utf-8') if sys.version_info[0] == 2 else self.val)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffWriteValue_args)
rffWriteValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.I32, 'row', None, None, ),  # 2
    (3, TType.I32, 'field', None, None, ),  # 3
    (4, TType.STRING, 'val', 'UTF8', None, ),  # 4
)


class rffWriteValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rffWriteValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rffWriteValue_result)
rffWriteValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareCleanTempDir_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareCleanTempDir_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareCleanTempDir_args)
runShareCleanTempDir_args.thrift_spec = (
)


class runShareCleanTempDir_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareCleanTempDir_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareCleanTempDir_result)
runShareCleanTempDir_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareGetBaseDirectory_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareGetBaseDirectory_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareGetBaseDirectory_args)
runShareGetBaseDirectory_args.thrift_spec = (
)


class runShareGetBaseDirectory_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareGetBaseDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareGetBaseDirectory_result)
runShareGetBaseDirectory_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareGetDirectory_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareGetDirectory_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareGetDirectory_args)
runShareGetDirectory_args.thrift_spec = (
)


class runShareGetDirectory_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareGetDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareGetDirectory_result)
runShareGetDirectory_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareHalt_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareHalt_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareHalt_args)
runShareHalt_args.thrift_spec = (
)


class runShareHalt_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareHalt_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareHalt_result)
runShareHalt_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareLock_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareLock_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareLock_args)
runShareLock_args.thrift_spec = (
)


class runShareLock_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareLock_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareLock_result)
runShareLock_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareRun_args(object):
    """
    Attributes:
     - cmd
     - ignoreErrors
     - autoChangeDir
     - shell

    """


    def __init__(self, cmd=None, ignoreErrors=None, autoChangeDir=None, shell=None,):
        self.cmd = cmd
        self.ignoreErrors = ignoreErrors
        self.autoChangeDir = autoChangeDir
        self.shell = shell

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cmd = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ignoreErrors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.autoChangeDir = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.shell = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareRun_args')
        if self.cmd is not None:
            oprot.writeFieldBegin('cmd', TType.STRING, 1)
            oprot.writeString(self.cmd.encode('utf-8') if sys.version_info[0] == 2 else self.cmd)
            oprot.writeFieldEnd()
        if self.ignoreErrors is not None:
            oprot.writeFieldBegin('ignoreErrors', TType.BOOL, 2)
            oprot.writeBool(self.ignoreErrors)
            oprot.writeFieldEnd()
        if self.autoChangeDir is not None:
            oprot.writeFieldBegin('autoChangeDir', TType.BOOL, 3)
            oprot.writeBool(self.autoChangeDir)
            oprot.writeFieldEnd()
        if self.shell is not None:
            oprot.writeFieldBegin('shell', TType.STRING, 4)
            oprot.writeString(self.shell.encode('utf-8') if sys.version_info[0] == 2 else self.shell)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareRun_args)
runShareRun_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cmd', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'ignoreErrors', None, None, ),  # 2
    (3, TType.BOOL, 'autoChangeDir', None, None, ),  # 3
    (4, TType.STRING, 'shell', 'UTF8', None, ),  # 4
)


class runShareRun_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareRun_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareRun_result)
runShareRun_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareSetAutoDelete_args(object):
    """
    Attributes:
     - autoDelete

    """


    def __init__(self, autoDelete=None,):
        self.autoDelete = autoDelete

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.autoDelete = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareSetAutoDelete_args')
        if self.autoDelete is not None:
            oprot.writeFieldBegin('autoDelete', TType.I32, 1)
            oprot.writeI32(self.autoDelete)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareSetAutoDelete_args)
runShareSetAutoDelete_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'autoDelete', None, None, ),  # 1
)


class runShareSetAutoDelete_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareSetAutoDelete_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareSetAutoDelete_result)
runShareSetAutoDelete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareSetFilesToCopy_args(object):
    """
    Attributes:
     - files

    """


    def __init__(self, files=None,):
        self.files = files

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.files = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareSetFilesToCopy_args')
        if self.files is not None:
            oprot.writeFieldBegin('files', TType.STRING, 1)
            oprot.writeString(self.files.encode('utf-8') if sys.version_info[0] == 2 else self.files)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareSetFilesToCopy_args)
runShareSetFilesToCopy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'files', 'UTF8', None, ),  # 1
)


class runShareSetFilesToCopy_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareSetFilesToCopy_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareSetFilesToCopy_result)
runShareSetFilesToCopy_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareSetMode_args(object):
    """
    Attributes:
     - mode

    """


    def __init__(self, mode=None,):
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareSetMode_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareSetMode_args)
runShareSetMode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
)


class runShareSetMode_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareSetMode_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareSetMode_result)
runShareSetMode_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class runShareUnlock_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareUnlock_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareUnlock_args)
runShareUnlock_args.thrift_spec = (
)


class runShareUnlock_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('runShareUnlock_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(runShareUnlock_result)
runShareUnlock_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objCallMethod_args(object):
    """
    Attributes:
     - varName
     - method

    """


    def __init__(self, varName=None, method=None,):
        self.varName = varName
        self.method = method

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.method = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objCallMethod_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 2)
            oprot.writeString(self.method.encode('utf-8') if sys.version_info[0] == 2 else self.method)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objCallMethod_args)
objCallMethod_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'method', 'UTF8', None, ),  # 2
)


class objCallMethod_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objCallMethod_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objCallMethod_result)
objCallMethod_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objDeleteAllMembers_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objDeleteAllMembers_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objDeleteAllMembers_args)
objDeleteAllMembers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class objDeleteAllMembers_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objDeleteAllMembers_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objDeleteAllMembers_result)
objDeleteAllMembers_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objDeleteMember_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objDeleteMember_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objDeleteMember_args)
objDeleteMember_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objDeleteMember_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objDeleteMember_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objDeleteMember_result)
objDeleteMember_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objFromFile_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - fileName

    """


    def __init__(self, varName=None, mIndex=None, fileName=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objFromFile_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 3)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objFromFile_args)
objFromFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'fileName', 'UTF8', None, ),  # 3
)


class objFromFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objFromFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objFromFile_result)
objFromFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objFromString_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objFromString_args)
objFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class objFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objFromString_result)
objFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objFromXML_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objFromXML_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objFromXML_args)
objFromXML_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class objFromXML_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objFromXML_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objFromXML_result)
objFromXML_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetBooleanArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index

    """


    def __init__(self, varName=None, mIndex=None, index=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetBooleanArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetBooleanArrayMemberValue_args)
objGetBooleanArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
)


class objGetBooleanArrayMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetBooleanArrayMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetBooleanArrayMemberValue_result)
objGetBooleanArrayMemberValue_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetBooleanMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetBooleanMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetBooleanMemberValue_args)
objGetBooleanMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetBooleanMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetBooleanMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetBooleanMemberValue_result)
objGetBooleanMemberValue_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetClassURL_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetClassURL_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetClassURL_args)
objGetClassURL_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class objGetClassURL_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetClassURL_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetClassURL_result)
objGetClassURL_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetDoubleArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index

    """


    def __init__(self, varName=None, mIndex=None, index=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetDoubleArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetDoubleArrayMemberValue_args)
objGetDoubleArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
)


class objGetDoubleArrayMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetDoubleArrayMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetDoubleArrayMemberValue_result)
objGetDoubleArrayMemberValue_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetDoubleMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetDoubleMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetDoubleMemberValue_args)
objGetDoubleMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetDoubleMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetDoubleMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetDoubleMemberValue_result)
objGetDoubleMemberValue_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetFileName_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetFileName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetFileName_args)
objGetFileName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetFileName_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetFileName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetFileName_result)
objGetFileName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetIntArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index

    """


    def __init__(self, varName=None, mIndex=None, index=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetIntArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetIntArrayMemberValue_args)
objGetIntArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
)


class objGetIntArrayMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetIntArrayMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetIntArrayMemberValue_result)
objGetIntArrayMemberValue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetIntMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetIntMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetIntMemberValue_args)
objGetIntMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetIntMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetIntMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetIntMemberValue_result)
objGetIntMemberValue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetIsBinary_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetIsBinary_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetIsBinary_args)
objGetIsBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetIsBinary_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetIsBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetIsBinary_result)
objGetIsBinary_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberDescription_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberDescription_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberDescription_args)
objGetMemberDescription_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberDescription_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberDescription_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberDescription_result)
objGetMemberDescription_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberDimensions_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberDimensions_args)
objGetMemberDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberDimensions_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberDimensions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberDimensions_result)
objGetMemberDimensions_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberEnumAliases_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberEnumAliases_args)
objGetMemberEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberEnumAliases_result)
objGetMemberEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberEnumValues_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberEnumValues_args)
objGetMemberEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberEnumValues_result)
objGetMemberEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberLength_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - dim

    """


    def __init__(self, varName=None, mIndex=None, dim=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.dim = dim

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dim = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberLength_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.dim is not None:
            oprot.writeFieldBegin('dim', TType.I32, 3)
            oprot.writeI32(self.dim)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberLength_args)
objGetMemberLength_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dim', None, None, ),  # 3
)


class objGetMemberLength_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberLength_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberLength_result)
objGetMemberLength_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberLowerBound_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberLowerBound_args)
objGetMemberLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberLowerBound_result)
objGetMemberLowerBound_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberNumDimensions_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberNumDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberNumDimensions_args)
objGetMemberNumDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberNumDimensions_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberNumDimensions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberNumDimensions_result)
objGetMemberNumDimensions_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberProperty_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - propertyName

    """


    def __init__(self, varName=None, mIndex=None, propertyName=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.propertyName = propertyName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.propertyName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberProperty_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.propertyName is not None:
            oprot.writeFieldBegin('propertyName', TType.STRING, 3)
            oprot.writeString(self.propertyName.encode('utf-8') if sys.version_info[0] == 2 else self.propertyName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberProperty_args)
objGetMemberProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'propertyName', 'UTF8', None, ),  # 3
)


class objGetMemberProperty_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberProperty_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberProperty_result)
objGetMemberProperty_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberType_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberType_args)
objGetMemberType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberType_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberType_result)
objGetMemberType_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberUnits_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberUnits_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberUnits_args)
objGetMemberUnits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberUnits_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberUnits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberUnits_result)
objGetMemberUnits_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberUpperBound_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberUpperBound_args)
objGetMemberUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberUpperBound_result)
objGetMemberUpperBound_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetMemberValueAsString_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberValueAsString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberValueAsString_args)
objGetMemberValueAsString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetMemberValueAsString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetMemberValueAsString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetMemberValueAsString_result)
objGetMemberValueAsString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetStringArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index

    """


    def __init__(self, varName=None, mIndex=None, index=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetStringArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetStringArrayMemberValue_args)
objGetStringArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
)


class objGetStringArrayMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetStringArrayMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetStringArrayMemberValue_result)
objGetStringArrayMemberValue_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objGetStringMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetStringMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetStringMemberValue_args)
objGetStringMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objGetStringMemberValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objGetStringMemberValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objGetStringMemberValue_result)
objGetStringMemberValue_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objHasMember_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objHasMember_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objHasMember_args)
objHasMember_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objHasMember_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objHasMember_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objHasMember_result)
objHasMember_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objHasMemberLowerBound_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objHasMemberLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objHasMemberLowerBound_args)
objHasMemberLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objHasMemberLowerBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objHasMemberLowerBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objHasMemberLowerBound_result)
objHasMemberLowerBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objHasMemberUpperBound_args(object):
    """
    Attributes:
     - varName
     - mIndex

    """


    def __init__(self, varName=None, mIndex=None,):
        self.varName = varName
        self.mIndex = mIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objHasMemberUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objHasMemberUpperBound_args)
objHasMemberUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
)


class objHasMemberUpperBound_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objHasMemberUpperBound_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objHasMemberUpperBound_result)
objHasMemberUpperBound_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objIsNonStrictType_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objIsNonStrictType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objIsNonStrictType_args)
objIsNonStrictType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class objIsNonStrictType_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objIsNonStrictType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objIsNonStrictType_result)
objIsNonStrictType_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetBaseName_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetBaseName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetBaseName_args)
objSetBaseName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetBaseName_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetBaseName_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetBaseName_result)
objSetBaseName_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetBooleanArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index
     - value

    """


    def __init__(self, varName=None, mIndex=None, index=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetBooleanArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 4)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetBooleanArrayMemberValue_args)
objSetBooleanArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'value', None, None, ),  # 4
)


class objSetBooleanArrayMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetBooleanArrayMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetBooleanArrayMemberValue_result)
objSetBooleanArrayMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetBooleanMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - boolVal

    """


    def __init__(self, varName=None, mIndex=None, boolVal=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetBooleanMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 3)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetBooleanMemberValue_args)
objSetBooleanMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'boolVal', None, None, ),  # 3
)


class objSetBooleanMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetBooleanMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetBooleanMemberValue_result)
objSetBooleanMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetDoubleArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index
     - value

    """


    def __init__(self, varName=None, mIndex=None, index=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetDoubleArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 4)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetDoubleArrayMemberValue_args)
objSetDoubleArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
    (4, TType.DOUBLE, 'value', None, None, ),  # 4
)


class objSetDoubleArrayMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetDoubleArrayMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetDoubleArrayMemberValue_result)
objSetDoubleArrayMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetDoubleMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetDoubleMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 3)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetDoubleMemberValue_args)
objSetDoubleMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.DOUBLE, 'value', None, None, ),  # 3
)


class objSetDoubleMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetDoubleMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetDoubleMemberValue_result)
objSetDoubleMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetFileExtension_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetFileExtension_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetFileExtension_args)
objSetFileExtension_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetFileExtension_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetFileExtension_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetFileExtension_result)
objSetFileExtension_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetFileName_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetFileName_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetFileName_args)
objSetFileName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetFileName_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetFileName_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetFileName_result)
objSetFileName_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetIntArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index
     - value

    """


    def __init__(self, varName=None, mIndex=None, index=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetIntArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 4)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetIntArrayMemberValue_args)
objSetIntArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
    (4, TType.I32, 'value', None, None, ),  # 4
)


class objSetIntArrayMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetIntArrayMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetIntArrayMemberValue_result)
objSetIntArrayMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetIntMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetIntMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 3)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetIntMemberValue_args)
objSetIntMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.I32, 'value', None, None, ),  # 3
)


class objSetIntMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetIntMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetIntMemberValue_result)
objSetIntMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetIsBinary_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - flag

    """


    def __init__(self, varName=None, mIndex=None, flag=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.flag = flag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.flag = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetIsBinary_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.BOOL, 3)
            oprot.writeBool(self.flag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetIsBinary_args)
objSetIsBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'flag', None, None, ),  # 3
)


class objSetIsBinary_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetIsBinary_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetIsBinary_result)
objSetIsBinary_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMember_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value
     - type

    """


    def __init__(self, varName=None, mIndex=None, value=None, type=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMember_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 4)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMember_args)
objSetMember_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'type', 'UTF8', None, ),  # 4
)


class objSetMember_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMember_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMember_result)
objSetMember_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberDescription_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberDescription_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberDescription_args)
objSetMemberDescription_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberDescription_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberDescription_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberDescription_result)
objSetMemberDescription_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberDimensions_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - strVal

    """


    def __init__(self, varName=None, mIndex=None, strVal=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberDimensions_args)
objSetMemberDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class objSetMemberDimensions_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberDimensions_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberDimensions_result)
objSetMemberDimensions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberEnumAliases_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberEnumAliases_args)
objSetMemberEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberEnumAliases_result)
objSetMemberEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberEnumValues_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberEnumValues_args)
objSetMemberEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberEnumValues_result)
objSetMemberEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberLength_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - length
     - dim

    """


    def __init__(self, varName=None, mIndex=None, length=None, dim=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.length = length
        self.dim = dim

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.dim = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberLength_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 3)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.dim is not None:
            oprot.writeFieldBegin('dim', TType.I32, 4)
            oprot.writeI32(self.dim)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberLength_args)
objSetMemberLength_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.I32, 'length', None, None, ),  # 3
    (4, TType.I32, 'dim', None, None, ),  # 4
)


class objSetMemberLength_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberLength_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberLength_result)
objSetMemberLength_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberLowerBound_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberLowerBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberLowerBound_args)
objSetMemberLowerBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberLowerBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberLowerBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberLowerBound_result)
objSetMemberLowerBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberProperty_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - propertyName
     - propertyValue

    """


    def __init__(self, varName=None, mIndex=None, propertyName=None, propertyValue=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.propertyName = propertyName
        self.propertyValue = propertyValue

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.propertyName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.propertyValue = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberProperty_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.propertyName is not None:
            oprot.writeFieldBegin('propertyName', TType.STRING, 3)
            oprot.writeString(self.propertyName.encode('utf-8') if sys.version_info[0] == 2 else self.propertyName)
            oprot.writeFieldEnd()
        if self.propertyValue is not None:
            oprot.writeFieldBegin('propertyValue', TType.STRING, 4)
            oprot.writeString(self.propertyValue.encode('utf-8') if sys.version_info[0] == 2 else self.propertyValue)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberProperty_args)
objSetMemberProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'propertyName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'propertyValue', 'UTF8', None, ),  # 4
)


class objSetMemberProperty_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberProperty_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberProperty_result)
objSetMemberProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberUnits_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberUnits_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberUnits_args)
objSetMemberUnits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberUnits_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberUnits_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberUnits_result)
objSetMemberUnits_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberUpperBound_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberUpperBound_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberUpperBound_args)
objSetMemberUpperBound_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberUpperBound_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberUpperBound_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberUpperBound_result)
objSetMemberUpperBound_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetMemberValueFromString_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberValueFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberValueFromString_args)
objSetMemberValueFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetMemberValueFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetMemberValueFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetMemberValueFromString_result)
objSetMemberValueFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetStringArrayMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - index
     - value

    """


    def __init__(self, varName=None, mIndex=None, index=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetStringArrayMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 3)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetStringArrayMemberValue_args)
objSetStringArrayMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'index', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
)


class objSetStringArrayMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetStringArrayMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetStringArrayMemberValue_result)
objSetStringArrayMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objSetStringMemberValue_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - value

    """


    def __init__(self, varName=None, mIndex=None, value=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetStringMemberValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetStringMemberValue_args)
objSetStringMemberValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class objSetStringMemberValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objSetStringMemberValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objSetStringMemberValue_result)
objSetStringMemberValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objToFile_args(object):
    """
    Attributes:
     - varName
     - mIndex
     - fileName

    """


    def __init__(self, varName=None, mIndex=None, fileName=None,):
        self.varName = varName
        self.mIndex = mIndex
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mIndex = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objToFile_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.mIndex is not None:
            oprot.writeFieldBegin('mIndex', TType.STRING, 2)
            oprot.writeString(self.mIndex.encode('utf-8') if sys.version_info[0] == 2 else self.mIndex)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 3)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objToFile_args)
objToFile_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mIndex', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'fileName', 'UTF8', None, ),  # 3
)


class objToFile_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objToFile_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objToFile_result)
objToFile_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objToString_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objToString_args)
objToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class objToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objToString_result)
objToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class objToXML_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objToXML_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objToXML_args)
objToXML_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class objToXML_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('objToXML_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(objToXML_result)
objToXML_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperAddMethod_args(object):
    """
    Attributes:
     - methodName
     - fullName
     - downloadInputs

    """


    def __init__(self, methodName=None, fullName=None, downloadInputs=None,):
        self.methodName = methodName
        self.fullName = fullName
        self.downloadInputs = downloadInputs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.methodName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fullName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.downloadInputs = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperAddMethod_args')
        if self.methodName is not None:
            oprot.writeFieldBegin('methodName', TType.STRING, 1)
            oprot.writeString(self.methodName.encode('utf-8') if sys.version_info[0] == 2 else self.methodName)
            oprot.writeFieldEnd()
        if self.fullName is not None:
            oprot.writeFieldBegin('fullName', TType.STRING, 2)
            oprot.writeString(self.fullName.encode('utf-8') if sys.version_info[0] == 2 else self.fullName)
            oprot.writeFieldEnd()
        if self.downloadInputs is not None:
            oprot.writeFieldBegin('downloadInputs', TType.BOOL, 3)
            oprot.writeBool(self.downloadInputs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperAddMethod_args)
wrapperAddMethod_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'methodName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'fullName', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'downloadInputs', None, None, ),  # 3
)


class wrapperAddMethod_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperAddMethod_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperAddMethod_result)
wrapperAddMethod_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperAddVariable_args(object):
    """
    Attributes:
     - varName
     - varType
     - isInput

    """


    def __init__(self, varName=None, varType=None, isInput=None,):
        self.varName = varName
        self.varType = varType
        self.isInput = isInput

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.varType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isInput = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperAddVariable_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.varType is not None:
            oprot.writeFieldBegin('varType', TType.STRING, 2)
            oprot.writeString(self.varType.encode('utf-8') if sys.version_info[0] == 2 else self.varType)
            oprot.writeFieldEnd()
        if self.isInput is not None:
            oprot.writeFieldBegin('isInput', TType.BOOL, 3)
            oprot.writeBool(self.isInput)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperAddVariable_args)
wrapperAddVariable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'varType', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isInput', None, None, ),  # 3
)


class wrapperAddVariable_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperAddVariable_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperAddVariable_result)
wrapperAddVariable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperGetDictKey_args(object):
    """
    Attributes:
     - index

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDictKey_args')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDictKey_args)
wrapperGetDictKey_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)


class wrapperGetDictKey_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDictKey_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDictKey_result)
wrapperGetDictKey_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperGetDictNumEntries_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDictNumEntries_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDictNumEntries_args)
wrapperGetDictNumEntries_args.thrift_spec = (
)


class wrapperGetDictNumEntries_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDictNumEntries_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDictNumEntries_result)
wrapperGetDictNumEntries_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperGetDictValue_args(object):
    """
    Attributes:
     - index

    """


    def __init__(self, index=None,):
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDictValue_args')
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 1)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDictValue_args)
wrapperGetDictValue_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'index', None, None, ),  # 1
)


class wrapperGetDictValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDictValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDictValue_result)
wrapperGetDictValue_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperGetDirectory_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDirectory_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDirectory_args)
wrapperGetDirectory_args.thrift_spec = (
)


class wrapperGetDirectory_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetDirectory_result)
wrapperGetDirectory_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperGetRunDirectory_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetRunDirectory_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetRunDirectory_args)
wrapperGetRunDirectory_args.thrift_spec = (
)


class wrapperGetRunDirectory_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetRunDirectory_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetRunDirectory_result)
wrapperGetRunDirectory_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperGetVarType_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetVarType_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetVarType_args)
wrapperGetVarType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class wrapperGetVarType_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperGetVarType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperGetVarType_result)
wrapperGetVarType_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperRemoveVariable_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperRemoveVariable_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperRemoveVariable_args)
wrapperRemoveVariable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class wrapperRemoveVariable_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperRemoveVariable_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperRemoveVariable_result)
wrapperRemoveVariable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class wrapperSleep_args(object):
    """
    Attributes:
     - milliSeconds

    """


    def __init__(self, milliSeconds=None,):
        self.milliSeconds = milliSeconds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.milliSeconds = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperSleep_args')
        if self.milliSeconds is not None:
            oprot.writeFieldBegin('milliSeconds', TType.I32, 1)
            oprot.writeI32(self.milliSeconds)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperSleep_args)
wrapperSleep_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'milliSeconds', None, None, ),  # 1
)


class wrapperSleep_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wrapperSleep_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wrapperSleep_result)
wrapperSleep_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayFromString_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayFromString_args)
arrayFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class arrayFromString_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayFromString_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayFromString_result)
arrayFromString_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayGetDimensions_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetDimensions_args)
arrayGetDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class arrayGetDimensions_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetDimensions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetDimensions_result)
arrayGetDimensions_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayGetLength_args(object):
    """
    Attributes:
     - varName
     - dim

    """


    def __init__(self, varName=None, dim=None,):
        self.varName = varName
        self.dim = dim

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dim = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetLength_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.dim is not None:
            oprot.writeFieldBegin('dim', TType.I32, 2)
            oprot.writeI32(self.dim)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetLength_args)
arrayGetLength_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'dim', None, None, ),  # 2
)


class arrayGetLength_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetLength_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetLength_result)
arrayGetLength_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayGetLockResize_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetLockResize_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetLockResize_args)
arrayGetLockResize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class arrayGetLockResize_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetLockResize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetLockResize_result)
arrayGetLockResize_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayGetNumDimensions_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetNumDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetNumDimensions_args)
arrayGetNumDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class arrayGetNumDimensions_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayGetNumDimensions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayGetNumDimensions_result)
arrayGetNumDimensions_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayLockDimensions_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayLockDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayLockDimensions_args)
arrayLockDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class arrayLockDimensions_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayLockDimensions_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayLockDimensions_result)
arrayLockDimensions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arraySetDimensions_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arraySetDimensions_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arraySetDimensions_args)
arraySetDimensions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class arraySetDimensions_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arraySetDimensions_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arraySetDimensions_result)
arraySetDimensions_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arraySetLength_args(object):
    """
    Attributes:
     - varName
     - length
     - dim

    """


    def __init__(self, varName=None, length=None, dim=None,):
        self.varName = varName
        self.length = length
        self.dim = dim

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dim = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arraySetLength_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 2)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.dim is not None:
            oprot.writeFieldBegin('dim', TType.I32, 3)
            oprot.writeI32(self.dim)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arraySetLength_args)
arraySetLength_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'length', None, None, ),  # 2
    (3, TType.I32, 'dim', None, None, ),  # 3
)


class arraySetLength_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arraySetLength_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arraySetLength_result)
arraySetLength_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arraySetLockResize_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arraySetLockResize_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arraySetLockResize_args)
arraySetLockResize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class arraySetLockResize_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arraySetLockResize_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arraySetLockResize_result)
arraySetLockResize_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class arrayToString_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayToString_args)
arrayToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class arrayToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('arrayToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(arrayToString_result)
arrayToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class simpleGetDescription_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleGetDescription_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleGetDescription_args)
simpleGetDescription_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class simpleGetDescription_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleGetDescription_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleGetDescription_result)
simpleGetDescription_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class simpleGetHasChanged_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleGetHasChanged_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleGetHasChanged_args)
simpleGetHasChanged_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class simpleGetHasChanged_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleGetHasChanged_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleGetHasChanged_result)
simpleGetHasChanged_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class simpleGetUnits_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleGetUnits_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleGetUnits_args)
simpleGetUnits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class simpleGetUnits_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleGetUnits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleGetUnits_result)
simpleGetUnits_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class simpleSetDescription_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleSetDescription_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleSetDescription_args)
simpleSetDescription_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class simpleSetDescription_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleSetDescription_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleSetDescription_result)
simpleSetDescription_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class simpleSetHasChanged_args(object):
    """
    Attributes:
     - varName
     - boolVal

    """


    def __init__(self, varName=None, boolVal=None,):
        self.varName = varName
        self.boolVal = boolVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.boolVal = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleSetHasChanged_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.boolVal is not None:
            oprot.writeFieldBegin('boolVal', TType.BOOL, 2)
            oprot.writeBool(self.boolVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleSetHasChanged_args)
simpleSetHasChanged_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'boolVal', None, None, ),  # 2
)


class simpleSetHasChanged_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleSetHasChanged_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleSetHasChanged_result)
simpleSetHasChanged_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class simpleSetUnits_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleSetUnits_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleSetUnits_args)
simpleSetUnits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class simpleSetUnits_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simpleSetUnits_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simpleSetUnits_result)
simpleSetUnits_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strGetEnumAliases_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strGetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strGetEnumAliases_args)
strGetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class strGetEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strGetEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strGetEnumAliases_result)
strGetEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strGetEnumValues_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strGetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strGetEnumValues_args)
strGetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class strGetEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strGetEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strGetEnumValues_result)
strGetEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strGetValue_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strGetValue_args)
strGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class strGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strGetValue_result)
strGetValue_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strSetEnumAliases_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strSetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strSetEnumAliases_args)
strSetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class strSetEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strSetEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strSetEnumAliases_result)
strSetEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strSetEnumValues_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strSetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strSetEnumValues_args)
strSetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class strSetEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strSetEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strSetEnumValues_result)
strSetEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strSetValue_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strSetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strSetValue_args)
strSetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class strSetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strSetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strSetValue_result)
strSetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArrayFromString_args(object):
    """
    Attributes:
     - varName
     - index
     - value

    """


    def __init__(self, varName=None, index=None, value=None,):
        self.varName = varName
        self.index = index
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayFromString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayFromString_args)
strArrayFromString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class strArrayFromString_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayFromString_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayFromString_result)
strArrayFromString_result.thrift_spec = (
)


class strArrayGetEnumAliases_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayGetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayGetEnumAliases_args)
strArrayGetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class strArrayGetEnumAliases_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayGetEnumAliases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayGetEnumAliases_result)
strArrayGetEnumAliases_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArrayGetEnumValues_args(object):
    """
    Attributes:
     - varName

    """


    def __init__(self, varName=None,):
        self.varName = varName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayGetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayGetEnumValues_args)
strArrayGetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
)


class strArrayGetEnumValues_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayGetEnumValues_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayGetEnumValues_result)
strArrayGetEnumValues_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArrayGetValue_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayGetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayGetValue_args)
strArrayGetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class strArrayGetValue_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayGetValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayGetValue_result)
strArrayGetValue_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArraySetEnumAliases_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArraySetEnumAliases_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArraySetEnumAliases_args)
strArraySetEnumAliases_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class strArraySetEnumAliases_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArraySetEnumAliases_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArraySetEnumAliases_result)
strArraySetEnumAliases_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArraySetEnumValues_args(object):
    """
    Attributes:
     - varName
     - strVal

    """


    def __init__(self, varName=None, strVal=None,):
        self.varName = varName
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArraySetEnumValues_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 2)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArraySetEnumValues_args)
strArraySetEnumValues_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'strVal', 'UTF8', None, ),  # 2
)


class strArraySetEnumValues_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArraySetEnumValues_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArraySetEnumValues_result)
strArraySetEnumValues_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArraySetValue_args(object):
    """
    Attributes:
     - varName
     - index
     - strVal

    """


    def __init__(self, varName=None, index=None, strVal=None,):
        self.varName = varName
        self.index = index
        self.strVal = strVal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.strVal = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArraySetValue_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        if self.strVal is not None:
            oprot.writeFieldBegin('strVal', TType.STRING, 3)
            oprot.writeString(self.strVal.encode('utf-8') if sys.version_info[0] == 2 else self.strVal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArraySetValue_args)
strArraySetValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'strVal', 'UTF8', None, ),  # 3
)


class strArraySetValue_result(object):
    """
    Attributes:
     - generalError

    """


    def __init__(self, generalError=None,):
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArraySetValue_result')
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArraySetValue_result)
strArraySetValue_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)


class strArrayToString_args(object):
    """
    Attributes:
     - varName
     - index

    """


    def __init__(self, varName=None, index=None,):
        self.varName = varName
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.varName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.index = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayToString_args')
        if self.varName is not None:
            oprot.writeFieldBegin('varName', TType.STRING, 1)
            oprot.writeString(self.varName.encode('utf-8') if sys.version_info[0] == 2 else self.varName)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.STRING, 2)
            oprot.writeString(self.index.encode('utf-8') if sys.version_info[0] == 2 else self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayToString_args)
strArrayToString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'varName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'index', 'UTF8', None, ),  # 2
)


class strArrayToString_result(object):
    """
    Attributes:
     - success
     - generalError

    """


    def __init__(self, success=None, generalError=None,):
        self.success = success
        self.generalError = generalError

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.generalError = GeneralError.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('strArrayToString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.generalError is not None:
            oprot.writeFieldBegin('generalError', TType.STRUCT, 1)
            self.generalError.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(strArrayToString_result)
strArrayToString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'generalError', [GeneralError, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
